{
  "q1_2025-04-26": {
    "id": "1745679159_1",
    "question": "[ANSWER_SEPARATOR]\n\n**Part 1 (Question):**\n\nConsider the following Python code that aims to create a decorator for asynchronous functions. The goal is to measure the execution time of an async function. However, the current implementation does not work as expected.\n\n```python\nimport asyncio\n\ndef time_decorator(func):\n    async def wrapper(*args, **kwargs):\n        start_time = asyncio.get_event_loop().time()\n        result = await func(*args, **kwargs)\n        end_time = asyncio.get_event_loop().time()\n        print(f\"Function {func.__name__} took {end_time - start_time:.4f} seconds\")\n        return result\n    return wrapper\n\n@time_decorator\nasync def sample_async_function():\n    await asyncio.sleep(2)\n    return \"Done\"\n\n# Running the function to test\nloop = asyncio.get_event_loop()\nresult = loop.run_until_complete(sample_async_function())\n```\n\nWhat is the issue with this code, and how can it be fixed?\n\nA) The decorator does not work because `asyncio.get_event_loop().time()` returns a coroutine.  \nB) The decorator works as expected, but the output format is incorrect.  \nC) The decorator should use `async def wrapper(*args, **kwargs):` instead of `def wrapper(*args, **kwargs):`.  \nD) The decorator should not measure execution time for asynchronous functions.\n\n**Part 2 (Answer):**\n\nA) The decorator does not work because `asyncio.get_event_loop().time()` returns a coroutine.  \nExplanation: The issue with the code lies in how the timing is being recorded. Since `asyncio.get_event_loop().time()` returns a function that provides the current time, it should be called directly to get the actual timestamp, not awaited. The correct usage would be `start_time = asyncio.get_event_loop().time()` and `end_time = asyncio.get_event_loop().time()`. This will give the current event loop's time in seconds when the function starts and ends, allowing the difference to calculate execution time.\n\n[ANSWER_SEPARATOR]",
    "answer": "Answer format error. Please check the generated content.",
    "timestamp": "2025-04-26 14:52:39",
    "topic": "Asynchronous Programming with asyncio"
  },
  "q2_2025-04-26": {
    "id": "1745685974_2",
    "question": "Part 1 (Question): \nImagine you are developing a web application where users can upload files. You want to ensure that only specific types of files (e.g., .txt, .pdf) can be uploaded. To achieve this, you decide to use decorators and metaclasses in Python.\n\nYou create a decorator `@allowed_file_types` that checks if the file type is allowed. Then, you define a metaclass `FileTypeMeta` that automatically applies the `@allowed_file_types` decorator to any class derived from it, setting the allowed types as a parameter.\n\nHere's a code snippet to get you started:\n\n```python\ndef allowed_file_types(*types):\n    def wrapper(cls):\n        cls.allowed_types = types\n        return cls\n    return wrapper\n\nclass FileTypeMeta(type):\n    def __new__(cls, name, bases, dct):\n        if 'allowed_types' not in dct:\n            dct['allowed_types'] = ()\n        super_new = super(FileTypeMeta, cls).__new__\n        return super_new(cls, name, bases, dct)\n\nclass AllowedFiles(metaclass=FileTypeMeta):\n    pass\n\nclass TextFile(AllowedFiles):\n    # TODO: Apply the allowed_file_types decorator here\n    pass\n\n# Example usage:\ntxt_file = TextFile()\nprint(txt_file.allowed_types)  # Should print ('.txt',)\n```\n\nWhich of the following ways can you correctly apply the `@allowed_file_types` decorator to the `TextFile` class using the metaclass?\n\nA) Use a direct assignment in the class definition.\nB) Override the `__new__` method in the metaclass to add the attribute.\nC) Use a class variable directly within the class definition.\nD) Call the `@allowed_file_types` decorator directly on the class.",
    "answer": "Part 2 (Answer): \nA) Direct assignment is not an option because decorators are applied before the class is fully defined, and direct assignment would occur after the class is created.\n\nB) Correct. By overriding the `__new__` method in the metaclass to add the attribute, you can ensure that any subclass of `AllowedFiles` will have its `allowed_types` attribute set by default if not explicitly provided.\n\nC) This would work but doesn't utilize the decorator mechanism and isn't as clean or flexible as using a metaclass.\n\nD) Calling the decorator directly on the class is also not correct because it bypasses the metaclass's influence, which should be used to set the `allowed_types` attribute.",
    "timestamp": "2025-04-26 16:46:14",
    "topic": "Python Metaclasses and Class Creation"
  },
  "q1_2025-04-27": {
    "id": "1745712127_1",
    "question": "[QUESTION]  \nYou are developing a Python library that needs to provide thread-safe logging functionality. You want to ensure that log messages from different threads do not interfere with each other, even when they are written simultaneously. Implement a decorator that can be applied to any function to make it thread-safe using locks.\n\n```python\nimport threading\n\n# Your solution goes here\n\ndef thread_safe_logger(func):\n    # Decorator code\n    pass\n\n@thread_safe_logger\ndef log_message(message):\n    print(f\"Log: {message}\")\n```\n\nChoose the correct implementation for the `thread_safe_logger` decorator:\n\nA)  \n```python\nlock = threading.Lock()\n\n@thread_safe_logger\ndef log_message(message):\n    with lock:\n        print(f\"Log: {message}\")\n```\n\nB)  \n```python\nlock = threading.Lock()\n\ndef thread_safe_logger(func):\n    def wrapper(*args, **kwargs):\n        with lock:\n            return func(*args, **kwargs)\n    return wrapper\n\n@thread_safe_logger\ndef log_message(message):\n    print(f\"Log: {message}\")\n```\n\nC)  \n```python\ndef thread_safe_logger(func):\n    lock = threading.Lock()\n    def wrapper(*args, **kwargs):\n        with lock:\n            return func(*args, **kwargs)\n    return wrapper\n\n@thread_safe_logger\ndef log_message(message):\n    print(f\"Log: {message}\")\n```\n\nD)  \n```python\nlock = threading.Lock()\n\ndef thread_safe_logger(func):\n    def wrapper(*args, **kwargs):\n        with lock:\n            print(f\"Log: {message}\")\n    return wrapper\n\n@thread_safe_logger\ndef log_message(message):\n    print(f\"Log: {message}\")\n```",
    "answer": "B)  \n```python\nlock = threading.Lock()\n\ndef thread_safe_logger(func):\n    def wrapper(*args, **kwargs):\n        with lock:\n            return func(*args, **kwargs)\n    return wrapper\n\n@thread_safe_logger\ndef log_message(message):\n    print(f\"Log: {message}\")\n```\n\n**Explanation**: The correct implementation is option B. In this solution, the `lock` is defined outside of the decorator function so that it is not recreated with each decorated function call. This ensures that all calls to the decorated functions use the same lock, making the logging thread-safe.",
    "timestamp": "2025-04-27 00:02:07",
    "topic": "Threading and Concurrent Execution"
  },
  "q2_2025-04-27": {
    "id": "1745740938_2",
    "question": "[QUESTION]\nConsider the following Python code snippet that aims to create a decorator to measure the execution time of any function it decorates:\n\n```python\nimport time\n\ndef time_decorator(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"Function {func.__name__} executed in {end_time - start_time:.4f} seconds\")\n        return result\n    return wrapper\n\n@time_decorator\ndef compute_sum(n):\n    return sum(range(n))\n```\n\nHowever, there is a common pitfall with this decorator that can lead to incorrect measurements. What is the issue with this code and how would you fix it?\n\nA) The decorator does not handle asynchronous functions.\n\nB) The decorator captures the start time too late, leading to inaccurate timing.\n\nC) The decorator does not allow the function to be called without any arguments.\n\nD) The decorator does not account for recursive calls properly.",
    "answer": "A) The decorator does not handle asynchronous functions.\n\n**Explanation:**\nThe provided decorator `time_decorator` is synchronous and will measure the total execution time of a synchronous function by capturing the start time before the function call and the end time after the function call. However, it does not account for the case where the function itself might be a coroutine (an asynchronous function). To handle both synchronous and asynchronous functions correctly, you would need to modify the decorator to check if the decorated function is a coroutine using `inspect.iscoroutinefunction`. If it is, you should use an asynchronous version of time measurement with `asyncio.get_event_loop().run_until_complete`.\n\nA corrected version of the decorator that handles both synchronous and asynchronous functions might look like this:\n\n```python\nimport asyncio\nimport time\nimport inspect\n\ndef time_decorator(func):\n    if inspect.iscoroutinefunction(func):\n        async def wrapper(*args, **kwargs):\n            start_time = time.time()\n            result = await func(*args, **kwargs)\n            end_time = time.time()\n            print(f\"Function {func.__name__} executed in {end_time - start_time:.4f} seconds\")\n            return result\n    else:\n        def wrapper(*args, **kwargs):\n            start_time = time.time()\n            result = func(*args, **kwargs)\n            end_time = time.time()\n            print(f\"Function {func.__name__} executed in {end_time - start_time:.4f} seconds\")\n            return result\n    return wrapper\n\n@time_decorator\nasync def compute_sum(n):\n    return sum(range(n))\n```\n\nThis version of the decorator uses conditional logic to determine whether to measure synchronous or asynchronous functions.",
    "timestamp": "2025-04-27 08:02:18",
    "topic": "Asynchronous Programming Concepts"
  },
  "q3_2025-04-27": {
    "id": "1745769714_3",
    "question": "[QUESTION]\nConsider the following Python code snippet:\n\n```python\nimport time\n\nclass Timer:\n    def __init__(self, name):\n        self.name = name\n\n    async def __aenter__(self):\n        print(f\"Starting {self.name}\")\n        self.start_time = time.time()\n        return self\n\n    async def __aexit__(self, exc_type, exc_value, traceback):\n        elapsed_time = time.time() - self.start_time\n        print(f\"{self.name} took {elapsed_time:.4f} seconds\")\n\nasync def main():\n    async with Timer(\"Task 1\"):\n        await asyncio.sleep(0.5)\n    async with Timer(\"Task 2\"):\n        await asyncio.sleep(0.3)\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())\n```\n\nWhich of the following statements about this code is true?\n\nA) The `Timer` class can be used as a context manager for synchronous tasks.\nB) The `Timer` class does not support asynchronous execution and will block when used in an async context.\nC) Both \"Task 1\" and \"Task 2\" will print their completion time to the console with high precision.\nD) Only \"Task 1\" will be able to complete successfully due to a bug.",
    "answer": "C) Both \"Task 1\" and \"Task 2\" will print their completion time to the console with high precision.\n\nExplanation: The `Timer` class is designed as an asynchronous context manager, which means it can be used in an async block (`async with`). The `__aenter__` method records the start time using `time.time()` and prints a message when entering the block. The `__aexit__` method calculates the elapsed time after exiting the block and prints it. Both tasks, \"Task 1\" and \"Task 2\", will run concurrently due to their usage within an async context manager (`async with`). Therefore, both tasks will measure their execution time accurately and print it to the console.",
    "timestamp": "2025-04-27 16:01:54",
    "topic": "Asynchronous Programming with asyncio"
  },
  "q1_2025-04-28": {
    "id": "1745798501_1",
    "question": "### Part 1 (Question)\n\nConsider the following code snippet that uses a metaclass to add a method to all classes dynamically:\n\n```python\nclass AddMethodMeta(type):\n    def __new__(cls, name, bases, dct):\n        dct['add_method'] = lambda self, x: x + 5\n        return super().__new__(cls, name, bases, dct)\n\nclass MyClass(metaclass=AddMethodMeta):\n    pass\n\nobj = MyClass()\nprint(obj.add_method(10))  # Output?\n```\n\nWhich of the following statements is true about this code?\n\nA) The output will be `15` because `add_method` adds 5 to its argument.\n\nB) The output will be an error because `add_method` is not defined in `MyClass`.\n\nC) The output will be `None` because metaclasses do not affect method definitions.\n\nD) The code will raise a TypeError because metaclasses cannot add methods dynamically.",
    "answer": "### Part 2 (Answer)\n\n**A) The output will be `15` because `add_method` adds 5 to its argument.**\n\nThis is the correct answer. In Python, metaclasses allow you to customize class creation by modifying or extending the class definition before it's finalized. In this case, the `AddMethodMeta` metaclass dynamically adds a method named `add_method` to any class it's applied to. When we create an instance of `MyClass`, it gains access to this new method, which simply returns its argument incremented by 5.\n\nThe line `print(obj.add_method(10))` will therefore output `15`.",
    "timestamp": "2025-04-28 00:01:41",
    "topic": "Python Metaclasses and Class Creation"
  },
  "q2_2025-04-28": {
    "id": "1745827307_2",
    "question": "[QUESTION]\nConsider the following Python code snippet that uses metaclasses and decorators:\n\n```python\nclass Meta(type):\n    def __new__(cls, name, bases, dct):\n        if 'greet' not in dct:\n            raise TypeError(\"Missing greet method\")\n        return super().__new__(cls, name, bases, dct)\n\ndef greeting_decorator(cls):\n    original_greet = cls.greet\n\n    def new_greet(self):\n        print(f\"Hello from {self.__class__.__name__}\")\n        original_greet(self)\n    \n    cls.greet = new_greet\n    return cls\n\n@greeting_decorator\nclass Person(metaclass=Meta):\n    def greet(self):\n        print(\"I am a person\")\n\nperson = Person()\nperson.greet()\n```\n\nWhich of the following statements is true about this code? Select all correct answers:\n\nA) The metaclass `Meta` checks if the subclass has a `greet` method before allowing it to be instantiated.\nB) The `greeting_decorator` modifies the `greet` method of any class it decorates, adding a greeting message at the beginning.\nC) When `person.greet()` is called, it will first print \"Hello from Person\" and then \"I am a person\".\nD) Both A and B are correct.",
    "answer": "[ANSWER] D\n\nExplanation:\nA) The metaclass `Meta` correctly checks if the subclass has a `greet` method. If not, it raises a `TypeError`, which is true.\nB) The `greeting_decorator` correctly modifies the `greet` method by adding a greeting message at the beginning, which is also true.\nC) Both A and B are correct because they both accurately describe aspects of how the code works.\nD) This answer is correct as it correctly identifies both parts A and B as being true.",
    "timestamp": "2025-04-28 08:01:47",
    "topic": "Python Metaclasses and Class Creation"
  },
  "q3_2025-04-28": {
    "id": "1745856116_3",
    "question": "[QUESTION]\nConsider the following Python code snippet:\n\n```python\nimport threading\n\ndef thread_safe(func):\n    def wrapper(*args, **kwargs):\n        lock = threading.Lock()\n        with lock:\n            return func(*args, **kwargs)\n    return wrapper\n\n@thread_safe\nclass SharedResource:\n    def __init__(self):\n        self.value = 0\n\n    def increment(self):\n        self.value += 1\n\ndef thread_function(resource, num_times):\n    for _ in range(num_times):\n        resource.increment()\n\nresource = SharedResource()\nthreads = [threading.Thread(target=thread_function, args=(resource, 100)) for _ in range(10)]\n\nfor thread in threads:\n    thread.start()\n\nfor thread in threads:\n    thread.join()\n\nprint(resource.value)\n```\n\nWhat is the expected output of this code? Why does it behave that way?\n\nA) The output will be 1000 because all increments are performed atomically.\n\nB) The output will be less than 1000 because multiple threads might read and write to `value` concurrently, leading to a race condition.\n\nC) The output will be more than 1000 due to extra increments caused by thread switching.\n\nD) The program will raise an exception due to improper use of the lock.",
    "answer": "B) The output will be less than 1000 because multiple threads might read and write to `value` concurrently, leading to a race condition.\n\nExplanation:\n- The decorator `@thread_safe` is intended to ensure that the `increment` method of `SharedResource` is thread-safe by using a lock.\n- However, the lock object is created inside the wrapper function for each call. This means that each `increment` call will use its own separate lock instead of sharing the same one across threads.\n- Since each thread uses its own lock and does not block other threads from reading and writing to `value`, race conditions can still occur.\n- Therefore, the final value of `resource.value` will be less than 1000, as multiple increments might be incorrectly applied.",
    "timestamp": "2025-04-28 16:01:56",
    "topic": "Threading and Concurrent Execution"
  },
  "q1_2025-04-29": {
    "id": "1745884916_1",
    "question": "[QUESTION]\nYou are tasked with creating a Python application that needs to track the creation of all instances of a certain class. You decide to use a metaclass for this purpose. Here is a partially complete code snippet:\n\n```python\nclass InstanceTracker(type):\n    _instances = {}\n\n    def __new__(cls, name, bases, dct):\n        new_class = super().__new__(cls, name, bases, dct)\n        # Task: Add code here to track the creation of instances\n        return new_class\n\nclass MyClass(metaclass=InstanceTracker):\n    pass\n\n# Usage\nobj1 = MyClass()\nobj2 = MyClass()\n\nprint(InstanceTracker._instances)  # Expected output: {'MyClass': [obj1, obj2]}\n```\n\nWhich line of code should be added to the `__new__` method in the `InstanceTracker` metaclass to track the creation of instances?\n\nA) `cls._instances[name].append(instance)`\nB) `self._instances[name] = []`\nC) `self._instances[name].append(self())`\nD) `self._instances[name].append(new_class())`",
    "answer": "[ANSWER] C\n\nExplanation:\nIn the provided code, we need to track the creation of instances of classes that use the `InstanceTracker` metaclass. The current implementation does not add any logic to track instances. \n\nOption A is incorrect because `instance` is not defined in the scope where this line would be executed.\nOption B is incorrect because it attempts to create a new list for each class but does not append any instances to it.\nOption C is correct because it appends an instance of the newly created class to a list associated with the class name. The `self()` call inside `append` creates a new instance of the class, which is then added to the list stored in `_instances`.\nOption D is incorrect because it tries to append the metaclass itself rather than an instance of the class.\n\nAdding this line to the `__new__` method will correctly track and store instances of classes that use the `InstanceTracker` metaclass.",
    "timestamp": "2025-04-29 00:01:56",
    "topic": "Task Management and Scheduling"
  },
  "q2_2025-04-29": {
    "id": "1745913715_2",
    "question": "[QUESTION]\nConsider the following Python code snippet:\n\n```python\nimport asyncio\n\nclass AsyncTimer:\n    def __init__(self, interval):\n        self.interval = interval\n        self.tasks = []\n\n    def add_task(self, coro):\n        task = asyncio.create_task(coro)\n        self.tasks.append(task)\n\n    async def run(self):\n        while True:\n            for task in self.tasks:\n                await task\n            await asyncio.sleep(self.interval)\n\nasync def my_coroutine():\n    print(\"Coroutine started\")\n    await asyncio.sleep(2)\n    print(\"Coroutine finished\")\n\n# Usage\ntimer = AsyncTimer(3)\ntimer.add_task(my_coroutine())\nasyncio.run(timer.run())\n```\n\nWhat is the behavior of this code, and what will be printed to the console? Explain why.\n\nA) The coroutine starts, waits for 2 seconds, then finishes. The timer runs in an infinite loop every 3 seconds, but since there's only one task, it doesn't add any complexity.\n\nB) The coroutine starts, waits for 2 seconds, then finishes. After that, the program will print nothing as the timer is not running any more tasks.\n\nC) The coroutine starts and stays alive indefinitely because the timer keeps scheduling itself to run every 3 seconds.\n\nD) There will be an error because adding a task to the `AsyncTimer` instance does not start it immediately.",
    "answer": "A) The coroutine starts, waits for 2 seconds, then finishes. The timer runs in an infinite loop every 3 seconds, but since there's only one task, it doesn't add any complexity.\n\nThe `run` method of the `AsyncTimer` class is designed to run indefinitely, continuously waiting for all tasks to complete before sleeping for the specified interval. Since the `my_coroutine` is added with a sleep duration of 2 seconds, it will complete after 2 seconds and then wait again for the next iteration of the timer loop (every 3 seconds). Therefore, the output will be \"Coroutine started\" followed by \"Coroutine finished\" every 3 seconds after the initial 2-second delay.",
    "timestamp": "2025-04-29 08:01:55",
    "topic": "Asynchronous Programming with asyncio"
  },
  "q3_2025-04-29": {
    "id": "1745942480_3",
    "question": "[QUESTION]  \nYou are tasked with creating a Python decorator that can be used to measure the execution time of any function it decorates. The decorator should be able to handle both synchronous and asynchronous functions seamlessly.\n\n```python\nimport time\n\n# Your metaclass or decorator goes here\ndef timing_decorator(func):\n    pass\n\n@timing_decorator\ndef sync_function():\n    time.sleep(1)\n\nasync def async_function():\n    await asyncio.sleep(1)\n```\n\nWhich of the following best demonstrates how to implement this `timing_decorator`?\n\nA) Use a metaclass to dynamically add timing logic at class creation.\nB) Create a synchronous decorator that uses the `time.time()` method.\nC) Create an asynchronous decorator that uses the `asyncio.get_event_loop().run_until_complete()` method.\nD) Implement both a synchronous and an asynchronous decorator, each using its respective timing method.",
    "answer": "[ANSWER] D  \nThe correct implementation involves creating two separate decorators: one for synchronous functions and another for asynchronous functions. The synchronous version will use `time.time()`, while the asynchronous version will utilize `asyncio.get_event_loop().run_until_complete()` to measure execution time accurately.",
    "timestamp": "2025-04-29 16:01:20",
    "topic": "Asynchronous Programming with asyncio"
  },
  "q1_2025-04-30": {
    "id": "1745971278_1",
    "question": "[QUESTION]  \nConsider the following Python code that uses a metaclass to modify class behavior dynamically:\n\n```python\nclass Meta(type):\n    def __new__(cls, name, bases, dct):\n        dct['new_attr'] = 'Hello from metaclass'\n        return super().__new__(cls, name, bases, dct)\n\nclass MyClass(metaclass=Meta):\n    pass\n\nobj = MyClass()\nprint(obj.new_attr)\n```\n\nWhat will be the output when running this code?\n\nA) Error  \nB) AttributeError: 'MyClass' object has no attribute 'new_attr'  \nC) Hello from metaclass  \nD) None",
    "answer": "C) Hello from metaclass\n\nExplanation:\nThe `Meta` class is a metaclass that dynamically adds an attribute `new_attr` to any class it's applied to. When the `MyClass` class is defined, the `Meta` metaclass modifies its dictionary to include `new_attr`. This new attribute is accessible as an instance attribute when creating an instance of `MyClass`, hence printing \"Hello from metaclass\".",
    "timestamp": "2025-04-30 00:01:18",
    "topic": "Object-Oriented Programming"
  },
  "q2_2025-04-30": {
    "id": "1746000109_2",
    "question": "[QUESTION]\nConsider the following Python code snippet:\n\n```python\nimport time\n\ndef time_decorator(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"Function {func.__name__} took {end_time - start_time:.4f} seconds to execute.\")\n        return result\n    return wrapper\n\n@time_decorator\nasync def async_task(n):\n    await asyncio.sleep(n)\n    return n\n\nasync def main():\n    tasks = [async_task(i) for i in range(5)]\n    results = await asyncio.gather(*tasks)\n    print(results)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\nWhat does this code do, and how can it be improved to ensure that the `time_decorator` works correctly with asynchronous functions?\n\nA) It measures the time taken for each task in `async_task` but has a race condition.\n\nB) It accurately measures the time taken for each task in `async_task`, but it will not work without `await asyncio.gather`.\n\nC) It measures the time taken for each task in `async_task` and works correctly with asynchronous functions. There is no need for any improvements.\n\nD) It measures the time taken for each task in `async_task`, but it won't print the results.",
    "answer": "[C] It measures the time taken for each task in `async_task` and works correctly with asynchronous functions. There is no need for any improvements.\n\nThe code provided uses a decorator to measure the execution time of an asynchronous function. The `time_decorator` is applied to `async_task`, which sleeps for a given number of seconds. When run, it accurately measures the time taken by each task using `await asyncio.sleep(n)` and prints it correctly. There are no issues with this code that would prevent it from working as intended.",
    "timestamp": "2025-04-30 08:01:49",
    "topic": "Asynchronous Programming with asyncio"
  },
  "q3_2025-04-30": {
    "id": "1746028942_3",
    "question": "[QUESTION]  \nConsider the following Python code snippet that uses a metaclass to modify class attributes dynamically:\n\n```python\nclass Meta(type):\n    def __new__(cls, name, bases, dct):\n        for attr_name in list(dct.keys()):\n            if isinstance(dct[attr_name], int):\n                dct[f'{attr_name}_description'] = f'This is an integer attribute: {attr_name}'\n        return super().__new__(cls, name, bases, dct)\n\nclass MyClass(metaclass=Meta):\n    x = 10\n    y = 'Hello'\n    z = 3.14\n```\n\nWhat will be the output of `MyClass.__dict__` after class creation?\n\nA) \n```python\n{\n    '__module__': '__main__',\n    'x': 10,\n    'y': 'Hello',\n    'z': 3.14,\n    'Meta': <class '__main__.Meta'>\n}\n```\n\nB) \n```python\n{\n    '__module__': '__main__',\n    'x': 10,\n    'x_description': 'This is an integer attribute: x',\n    'y': 'Hello',\n    'z': 3.14,\n    'z_description': 'This is an integer attribute: z',\n    'Meta': <class '__main__.Meta'>\n}\n```\n\nC) \n```python\n{\n    '__module__': '__main__',\n    'x': 10,\n    'y': 'Hello',\n    'z': 3.14,\n    '__new__': <function Meta.__new__ at ...>,\n    'Meta': <class '__main__.Meta'>\n}\n```\n\nD) \n```python\n{\n    '__module__': '__main__',\n    'x': 10,\n    'x_description': 'This is an integer attribute: x',\n    'y': 'Hello',\n    '__new__': <function Meta.__new__ at ...>,\n    'Meta': <class '__main__.Meta'>\n}\n```",
    "answer": "D) \n\nThe correct answer is D. The metaclass `Meta` dynamically adds a new attribute to each integer attribute in the class, but it only affects attributes named with a single letter ('x', 'z'). This is because when the `Meta` metaclass iterates over all attributes, it includes inherited attributes as well. In this case, since 'y' is not an integer, no additional attribute is added for it. The '__new__' method of the metaclass is included in the class dictionary because metaclasses define their own `__new__` method to create and return a new class object.",
    "timestamp": "2025-04-30 16:02:22",
    "topic": "Object-Oriented Programming"
  },
  "q1_2025-05-01": {
    "id": "1746057701_1",
    "question": "[QUESTION]\nConsider the following Python code that uses a metaclass to control class creation:\n\n```python\nclass Meta(type):\n    def __new__(cls, name, bases, dct):\n        if 'x' not in dct:\n            raise TypeError(\"Class must have an attribute 'x'\")\n        return super().__new__(cls, name, bases, dct)\n\nclass MyClass(metaclass=Meta):\n    x = 10\n```\n\nWhich of the following statements is true regarding this code?\n\nA) When `MyClass` is defined, it does not raise any errors.\nB) If you remove the line `x = 10` from `MyClass`, it will raise a `TypeError`.\nC) The metaclass `Meta` can be used to enforce that all classes inheriting from `MyClass` must also define an attribute `x`.\nD) The metaclass `Meta` cannot be instantiated directly.",
    "answer": "B) If you remove the line `x = 10` from `MyClass`, it will raise a `TypeError`.\n\nExplanation:\n- Option A is incorrect because the code does not run without errors. It raises a `TypeError` during class creation.\n- Option C is incorrect because metaclasses like `Meta` control the creation of classes, not their inheritance.\n- Option D is correct because a metaclass itself is just a class that inherits from `type`, and it can be instantiated as any other class.\n- Option B is correct. The metaclass `Meta` checks if the attribute `x` is present in the class dictionary when the class is being created. If it's not, it raises a `TypeError`.",
    "timestamp": "2025-05-01 00:01:41",
    "topic": "Object-Oriented Programming"
  },
  "q2_2025-05-01": {
    "id": "1746086558_2",
    "question": "[QUESTION]\nYou are tasked with creating a context manager that logs the time taken for each block of code it decorates. However, you want this logging to be performed asynchronously, so that it does not block the main execution flow. Your task is to design such a context manager using Python's `asyncio` library.\n\nHere's a partially implemented version of your context manager:\n\n```python\nimport asyncio\n\nclass AsyncTimerContextManager:\n    async def __aenter__(self):\n        self.start_time = time.time()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        end_time = time.time()\n        await self.log_time_taken(end_time - self.start_time)\n\n    @staticmethod\n    async def log_time_taken(duration):\n        print(f\"Time taken: {duration:.2f} seconds\")\n\n# Example usage:\nasync def main():\n    async with AsyncTimerContextManager() as timer:\n        # Simulate some asynchronous work\n        await asyncio.sleep(1)\n        print(\"Work completed!\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\nHowever, this code has an issue: it does not correctly handle exceptions that might occur within the `with` block. You need to ensure that any exceptions raised inside the `with` block are propagated and handled by the caller of `async with`.\n\nWhat change should you make to the `AsyncTimerContextManager` class to correctly propagate exceptions?\n\nA) Add a check for `exc_type` inside the `__aexit__` method and re-raise the exception if it is not `None`.\n\nB) Wrap the code that calculates and logs the duration in a try-except block.\n\nC) Remove the `return self` statement from the `__aenter__` method.\n\nD) Change the `log_time_taken` method to be an instance method instead of a static method.",
    "answer": "A) Add a check for `exc_type` inside the `__aexit__` method and re-raise the exception if it is not `None`.\n\nThe correct answer is A. In the `__aexit__` method, you should add a condition to check if an exception occurred (`if exc_type`). If an exception did occur, you should re-raise it using `raise exc_val from exc_tb`. This ensures that any exceptions raised within the `with` block are propagated and handled correctly by the caller of `async with`.\n\nHere's the corrected version of the context manager:\n\n```python\nimport asyncio\n\nclass AsyncTimerContextManager:\n    async def __aenter__(self):\n        self.start_time = time.time()\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        end_time = time.time()\n        if exc_type is None:\n            await self.log_time_taken(end_time - self.start_time)\n        else:\n            raise exc_val from exc_tb\n\n    @staticmethod\n    async def log_time_taken(duration):\n        print(f\"Time taken: {duration:.2f} seconds\")\n\n# Example usage remains the same\n```\n\nThis implementation ensures that exceptions are correctly propagated, allowing for proper error handling in the code using the context manager.",
    "timestamp": "2025-05-01 08:02:38",
    "topic": "Asynchronous Programming with asyncio"
  }
}