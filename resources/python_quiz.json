{
  "q1_2025-04-26": {
    "id": "1745679159_1",
    "question": "[ANSWER_SEPARATOR]\n\n**Part 1 (Question):**\n\nConsider the following Python code that aims to create a decorator for asynchronous functions. The goal is to measure the execution time of an async function. However, the current implementation does not work as expected.\n\n```python\nimport asyncio\n\ndef time_decorator(func):\n    async def wrapper(*args, **kwargs):\n        start_time = asyncio.get_event_loop().time()\n        result = await func(*args, **kwargs)\n        end_time = asyncio.get_event_loop().time()\n        print(f\"Function {func.__name__} took {end_time - start_time:.4f} seconds\")\n        return result\n    return wrapper\n\n@time_decorator\nasync def sample_async_function():\n    await asyncio.sleep(2)\n    return \"Done\"\n\n# Running the function to test\nloop = asyncio.get_event_loop()\nresult = loop.run_until_complete(sample_async_function())\n```\n\nWhat is the issue with this code, and how can it be fixed?\n\nA) The decorator does not work because `asyncio.get_event_loop().time()` returns a coroutine.  \nB) The decorator works as expected, but the output format is incorrect.  \nC) The decorator should use `async def wrapper(*args, **kwargs):` instead of `def wrapper(*args, **kwargs):`.  \nD) The decorator should not measure execution time for asynchronous functions.\n\n**Part 2 (Answer):**\n\nA) The decorator does not work because `asyncio.get_event_loop().time()` returns a coroutine.  \nExplanation: The issue with the code lies in how the timing is being recorded. Since `asyncio.get_event_loop().time()` returns a function that provides the current time, it should be called directly to get the actual timestamp, not awaited. The correct usage would be `start_time = asyncio.get_event_loop().time()` and `end_time = asyncio.get_event_loop().time()`. This will give the current event loop's time in seconds when the function starts and ends, allowing the difference to calculate execution time.\n\n[ANSWER_SEPARATOR]",
    "answer": "Answer format error. Please check the generated content.",
    "timestamp": "2025-04-26 14:52:39",
    "topic": "Asynchronous Programming with asyncio"
  },
  "q2_2025-04-26": {
    "id": "1745685974_2",
    "question": "Part 1 (Question): \nImagine you are developing a web application where users can upload files. You want to ensure that only specific types of files (e.g., .txt, .pdf) can be uploaded. To achieve this, you decide to use decorators and metaclasses in Python.\n\nYou create a decorator `@allowed_file_types` that checks if the file type is allowed. Then, you define a metaclass `FileTypeMeta` that automatically applies the `@allowed_file_types` decorator to any class derived from it, setting the allowed types as a parameter.\n\nHere's a code snippet to get you started:\n\n```python\ndef allowed_file_types(*types):\n    def wrapper(cls):\n        cls.allowed_types = types\n        return cls\n    return wrapper\n\nclass FileTypeMeta(type):\n    def __new__(cls, name, bases, dct):\n        if 'allowed_types' not in dct:\n            dct['allowed_types'] = ()\n        super_new = super(FileTypeMeta, cls).__new__\n        return super_new(cls, name, bases, dct)\n\nclass AllowedFiles(metaclass=FileTypeMeta):\n    pass\n\nclass TextFile(AllowedFiles):\n    # TODO: Apply the allowed_file_types decorator here\n    pass\n\n# Example usage:\ntxt_file = TextFile()\nprint(txt_file.allowed_types)  # Should print ('.txt',)\n```\n\nWhich of the following ways can you correctly apply the `@allowed_file_types` decorator to the `TextFile` class using the metaclass?\n\nA) Use a direct assignment in the class definition.\nB) Override the `__new__` method in the metaclass to add the attribute.\nC) Use a class variable directly within the class definition.\nD) Call the `@allowed_file_types` decorator directly on the class.",
    "answer": "Part 2 (Answer): \nA) Direct assignment is not an option because decorators are applied before the class is fully defined, and direct assignment would occur after the class is created.\n\nB) Correct. By overriding the `__new__` method in the metaclass to add the attribute, you can ensure that any subclass of `AllowedFiles` will have its `allowed_types` attribute set by default if not explicitly provided.\n\nC) This would work but doesn't utilize the decorator mechanism and isn't as clean or flexible as using a metaclass.\n\nD) Calling the decorator directly on the class is also not correct because it bypasses the metaclass's influence, which should be used to set the `allowed_types` attribute.",
    "timestamp": "2025-04-26 16:46:14",
    "topic": "Python Metaclasses and Class Creation"
  },
  "q1_2025-04-27": {
    "id": "1745712127_1",
    "question": "[QUESTION]  \nYou are developing a Python library that needs to provide thread-safe logging functionality. You want to ensure that log messages from different threads do not interfere with each other, even when they are written simultaneously. Implement a decorator that can be applied to any function to make it thread-safe using locks.\n\n```python\nimport threading\n\n# Your solution goes here\n\ndef thread_safe_logger(func):\n    # Decorator code\n    pass\n\n@thread_safe_logger\ndef log_message(message):\n    print(f\"Log: {message}\")\n```\n\nChoose the correct implementation for the `thread_safe_logger` decorator:\n\nA)  \n```python\nlock = threading.Lock()\n\n@thread_safe_logger\ndef log_message(message):\n    with lock:\n        print(f\"Log: {message}\")\n```\n\nB)  \n```python\nlock = threading.Lock()\n\ndef thread_safe_logger(func):\n    def wrapper(*args, **kwargs):\n        with lock:\n            return func(*args, **kwargs)\n    return wrapper\n\n@thread_safe_logger\ndef log_message(message):\n    print(f\"Log: {message}\")\n```\n\nC)  \n```python\ndef thread_safe_logger(func):\n    lock = threading.Lock()\n    def wrapper(*args, **kwargs):\n        with lock:\n            return func(*args, **kwargs)\n    return wrapper\n\n@thread_safe_logger\ndef log_message(message):\n    print(f\"Log: {message}\")\n```\n\nD)  \n```python\nlock = threading.Lock()\n\ndef thread_safe_logger(func):\n    def wrapper(*args, **kwargs):\n        with lock:\n            print(f\"Log: {message}\")\n    return wrapper\n\n@thread_safe_logger\ndef log_message(message):\n    print(f\"Log: {message}\")\n```",
    "answer": "B)  \n```python\nlock = threading.Lock()\n\ndef thread_safe_logger(func):\n    def wrapper(*args, **kwargs):\n        with lock:\n            return func(*args, **kwargs)\n    return wrapper\n\n@thread_safe_logger\ndef log_message(message):\n    print(f\"Log: {message}\")\n```\n\n**Explanation**: The correct implementation is option B. In this solution, the `lock` is defined outside of the decorator function so that it is not recreated with each decorated function call. This ensures that all calls to the decorated functions use the same lock, making the logging thread-safe.",
    "timestamp": "2025-04-27 00:02:07",
    "topic": "Threading and Concurrent Execution"
  }
}