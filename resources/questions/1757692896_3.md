# Python Quiz Question
    
    ## Question
    [QUESTION]
Consider the following Python code that uses decorators and metaclasses together:

```python
from abc import ABC, abstractmethod

class Meta(type):
    def __new__(cls, name, bases, dct):
        if 'abstract_method' not in dct:
            raise TypeError(f"{name} must implement abstract_method")
        return super().__new__(cls, name, bases, dct)

class Base(metaclass=Meta):
    @abstractmethod
    def abstract_method(self):
        pass

def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Decorator is running!")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
class MyClass(Base):
    def abstract_method(self):
        print("Abstract method is called!")

# Create an instance of MyClass and call the abstract_method
instance = MyClass()
instance.abstract_method()
```

What will be printed when you run this code?

A) Decorator is running!  
   Abstract method is called!

B) TypeError: MyClass must implement abstract_method

C) NameError: name 'MyClass' is not defined

D) SyntaxError: invalid syntax
    
    ## Answer
    A) Decorator is running!  
   Abstract method is called!

The code first checks if `abstract_method` is implemented in the subclass of `Base`. Since it is, an instance of `MyClass` is created and the abstract method is called. The decorator runs before the abstract method, printing "Decorator is running!" followed by "Abstract method is called!".
    
    ---
    *Generated on: 2025-09-12 16:01:36*
    