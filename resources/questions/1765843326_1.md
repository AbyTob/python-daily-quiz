# Python Quiz Question
    
    ## Question
    [QUESTION]
Consider the following code snippet that attempts to create a decorator to measure the execution time of functions:

```python
import time

def time_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Executing {func.__name__} took {end_time - start_time} seconds.")
        return result
    return wrapper

@time_decorator
def compute_sum(n):
    return sum(range(n))

print(compute_sum(1000000))
```

However, when this code is run, it does not work as expected. Identify the issue and provide a corrected version of the `time_decorator` that properly measures the execution time.

A) The decorator is incorrectly capturing variables in its closure.
B) The wrapper function is missing an `async` keyword if the decorated function is asynchronous.
C) The print statement should be inside the function to measure time accurately.
D) The decorator does not handle exceptions thrown by the wrapped function.
    
    ## Answer
    A) The decorator is incorrectly capturing variables in its closure.

Explanation: In Python, decorators create closures. However, in this case, the `wrapper` function directly captures the `start_time` and `end_time` variables from the enclosing scope, which can lead to unexpected behavior if these variables are reused or modified elsewhere. To correct this, the decorator should be designed to handle its own local variables for timing.

Corrected code:
```python
import time

def time_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Executing {func.__name__} took {end_time - start_time} seconds.")
        return result
    return wrapper

@time_decorator
def compute_sum(n):
    return sum(range(n))

print(compute_sum(1000000))
```
    
    ---
    *Generated on: 2025-12-16 00:02:06*
    