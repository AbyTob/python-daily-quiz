# Python Quiz Question
    
    ## Question
    **Part 1 (Question):**

Consider the following code snippet:

```python
import asyncio

async def fetch_data():
    print("Fetching data...")
    await asyncio.sleep(2)
    return "Data fetched"

class AsyncDecorator:
    def __init__(self, func):
        self.func = func

    async def __call__(self, *args, **kwargs):
        start_time = time.time()
        result = await self.func(*args, **kwargs)
        end_time = time.time()
        print(f"Execution time: {end_time - start_time} seconds")
        return result

@AsyncDecorator
async def main():
    data = await fetch_data()
    print(data)

# Run the async function
import time
asyncio.run(main())
```

What happens when you run this code, and why? What will be printed to the console?

A) "Fetching data...", "Execution time: 2.0 seconds", and "Data fetched"

B) "Fetching data...", and "Execution time: 2.0 seconds" without printing "Data fetched"

C) An error because `time.time()` cannot be used in an async context

D) A warning indicating that using `time.time()` with asyncio is deprecated

**Part 2 (Answer):**

A) "Fetching data...", "Execution time: 2.0 seconds", and "Data fetched"

Explanation:
- The `AsyncDecorator` class is a decorator designed to measure the execution time of an asynchronous function.
- When `main()` is called, it wraps `fetch_data()` with `@AsyncDecorator`.
- Inside `__call__`, `time.time()` is used to calculate the start and end times before and after calling `self.func(*args, **kwargs)`. This works because `time.time()` is a synchronous function, and asyncio can run both synchronous and asynchronous code concurrently.
- The `await` keyword ensures that the event loop waits for `fetch_data()` to complete before moving on to print "Execution time".
- Therefore, all three print statements are executed in sequence.
    
    ## Answer
    Answer format error. Please check the generated content.
    
    ---
    *Generated on: 2025-11-11 08:01:59*
    