# Python Quiz Question
    
    ## Question
    ### Part 1 (Question)

Consider the following Python code:

```python
import asyncio

class AsyncDecorator:
    def __init__(self, func):
        self.func = func
    
    async def __call__(self, *args, **kwargs):
        print("Before function execution")
        result = await self.func(*args, **kwargs)
        print("After function execution")
        return result

@AsyncDecorator
async def my_async_function():
    await asyncio.sleep(1)
    return "Function executed"

# Usage
asyncio.run(my_async_function())
```

Which of the following statements accurately describes the behavior of this code?

A) The decorator `AsyncDecorator` will not run because it is applied to an asynchronous function.

B) When called, `my_async_function` will execute immediately and then print "After function execution".

C) When `asyncio.run(my_async_function())` is executed, it will first print "Before function execution", wait for 1 second, then print "Function executed" and finally print "After function execution".

D) The decorator `AsyncDecorator` will raise an error because it is trying to handle an asynchronous function.
    
    ## Answer
    ### Part 2 (Answer)

C) When `asyncio.run(my_async_function())` is executed, it will first print "Before function execution", wait for 1 second, then print "Function executed" and finally print "After function execution".

Explanation: The decorator `AsyncDecorator` correctly handles the asynchronous nature of `my_async_function`. It prints "Before function execution", awaits the completion of `my_async_function`, prints "Function executed", and then completes its own execution by printing "After function execution". The `asyncio.run()` function is used to run an entry point coroutine, which in this case is `my_async_function` decorated with `AsyncDecorator`.
    
    ---
    *Generated on: 2025-09-04 16:01:47*
    