# Python Quiz Question
    
    ## Question
    ### Part 1 (Question):

Consider the following Python code:

```python
import asyncio

class AsyncDecorator:
    def __init__(self, func):
        self.func = func
    
    def __call__(self, *args, **kwargs):
        async def wrapper(*args, **kwargs):
            result = await self.func(*args, **kwargs)
            return result
        return wrapper

@AsyncDecorator
async def fetch_data():
    await asyncio.sleep(1)  # Simulate an IO-bound task
    return "Data fetched"

async def main():
    data = await fetch_data()
    print(data)

# Running the async function
asyncio.run(main())
```

Which of the following statements correctly describes what happens when you run this code?

A) The `fetch_data` function runs synchronously, blocking the event loop for 1 second.

B) The `fetch_data` function is decorated with a class-based decorator `AsyncDecorator`, which converts it into an async function. When called within `main`, it uses the event loop to perform the task asynchronously.

C) The `fetch_data` function runs asynchronously, but since it calls `asyncio.sleep(1)` internally, it effectively blocks the event loop for 1 second.

D) The `AsyncDecorator` class is used incorrectly, and the code will result in a `TypeError`.
    
    ## Answer
    ### Part 2 (Answer):

B) The `fetch_data` function is decorated with a class-based decorator `AsyncDecorator`, which converts it into an async function. When called within `main`, it uses the event loop to perform the task asynchronously.

**Explanation:**
- The `AsyncDecorator` class is a decorator that wraps any callable, converting it into an asynchronous function using an inner `wrapper` coroutine.
- The `fetch_data` function is defined as an `async def`, but since it's decorated with `@AsyncDecorator`, the actual execution of `fetch_data` inside `main` will be handled asynchronously by the event loop.
- When `await fetch_data()` is called in `main`, it schedules `fetch_data` to run asynchronously. The event loop runs this coroutine, waits for 1 second as simulated by `asyncio.sleep(1)`, and then returns "Data fetched".
- This demonstrates how a class-based decorator can be used to convert synchronous functions into asynchronous ones, facilitating the use of async/await syntax effectively.
    
    ---
    *Generated on: 2025-10-04 08:02:15*
    