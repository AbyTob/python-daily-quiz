# Python Quiz Question
    
    ## Question
    
    
    ## Answer
    **Part 1 (Question):**

Consider the following Python code snippet that uses decorators, metaclasses, and async/await:

```python
import asyncio

class AsyncMeta(type):
    def __new__(cls, name, bases, dct):
        if 'async_method' in dct:
            dct['sync_method'] = cls.convert_to_sync(dct['async_method'])
        return super().__new__(cls, name, bases, dct)

    @staticmethod
    def convert_to_sync(async_func):
        async def sync_wrapper(*args, **kwargs):
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(None, async_func, *args, **kwargs)
        return sync_wrapper

class AsyncClass(metaclass=AsyncMeta):
    async def async_method(self, value):
        return value * 2

async def main():
    obj = AsyncClass()
    print(obj.sync_method(5))

# Run the async function and wait for it to complete
asyncio.run(main())
```

What does this code do when run? Choose from the following options:

A) It prints `10` and then completes.
B) It raises a `TypeError`.
C) It enters an infinite loop.
D) It crashes with an unhandled exception.

**Part 2 (Answer):**

A) It prints `10` and then completes.

Explanation:
This code uses a metaclass to automatically convert any asynchronous method in a class into a synchronous one. When you call `obj.sync_method(5)`, it internally runs the `async_method` asynchronously using an event loop, converts its result to a synchronous value, and returns it. Thus, when printed, it correctly outputs `10`. The `AsyncMeta` metaclass checks if there is an `async_method` in the class dictionary and replaces it with a new method (`sync_method`) that runs the original asynchronous method in the event loop using `run_in_executor`, effectively making it synchronous.
    
    ---
    *Generated on: 2025-09-07 16:01:54*
    