# Python Quiz Question
    
    ## Question
    ### Part 1 (Question)
Consider the following Python code that uses a metaclass and decorators:

```python
from functools import wraps

def log_function_call(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        return func(*args, **kwargs)
    return wrapper

class Meta(type):
    def __new__(cls, name, bases, dct):
        for attr_name, attr_value in dct.items():
            if callable(attr_value):
                dct[attr_name] = log_function_call(attr_value)
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=Meta):
    def method1(self, x):
        return x * 2
    
    @staticmethod
    def static_method(y):
        return y + 5

# Example usage:
instance = MyClass()
print(instance.method1(3))
print(MyClass.static_method(4))
```

What will be the output when running this code? 

A) 
```
Calling method1 with args: (3,), kwargs: {}
6
Calling static_method with args: (4,), kwargs: {}
9
```

B)
```
Calling method1 with args: (3,), kwargs: {}
6
static_method(4)
```

C)
```
method1(3)
 Calling 6
static_method(4)
 Calling 9
```

D)
```
6
9
```
    
    ## Answer
    ### Part 2 (Answer)
**Correct Answer:** A

**Explanation:**
- The `log_function_call` decorator is used to log the calls to any callable method within the class.
- When a class is created using the `Meta` metaclass, it automatically wraps all callable methods in the `MyClass` with the `log_function_call` decorator.
- Therefore, when an instance of `MyClass` is created and its methods are called, the decorator logs the calls before executing the method.

Here's how the output corresponds to option A:
1. The call to `instance.method1(3)` logs "Calling method1 with args: (3,), kwargs: {}" and then returns `6`.
2. The call to `MyClass.static_method(4)` logs "Calling static_method with args: (4,), kwargs: {}" and then returns `9`.
    
    ---
    *Generated on: 2025-12-23 00:02:32*
    