# Python Quiz Question
    
    ## Question
    Part 1 (Question):
Consider the following Python code snippet that aims to create a decorator to measure the execution time of functions:

```python
import time

def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Function {func.__name__} took {end_time - start_time:.4f} seconds to execute.")
        return result
    return wrapper

@timing_decorator
def compute_sum(n):
    return sum(range(n))

result = compute_sum(1000000)
```

What is a potential issue with the current implementation of the `timing_decorator`?

A) It does not support asynchronous functions.
B) The decorator modifies the original function signature.
C) It causes a memory leak when applied to large functions.
D) The output will always be 0 seconds.
    
    ## Answer
    Part 2 (Answer):
A) It does not support asynchronous functions.
This is incorrect because the `timing_decorator` works with both synchronous and asynchronous functions. To make it work with async functions, you would need to modify the decorator to use `async def wrapper` and call `await func(*args, **kwargs)`.

B) The decorator modifies the original function signature.
This is correct. While not an issue for this specific example, decorators can potentially alter the docstring, name, or other attributes of the decorated function, leading to unexpected behavior when using tools that rely on these attributes.

C) It causes a memory leak when applied to large functions.
This is incorrect. The decorator itself does not cause memory leaks; it merely adds timing functionality without additional overhead.

D) The output will always be 0 seconds.
This is incorrect because the decorator correctly measures and prints the execution time of `compute_sum`.
    
    ---
    *Generated on: 2025-08-27 00:01:50*
    