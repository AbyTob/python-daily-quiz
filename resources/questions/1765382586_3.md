# Python Quiz Question
    
    ## Question
    
    
    ## Answer
    **Part 1 (Question):**

Consider the following Python code that utilizes decorators and metaclasses to enhance a class's behavior. The goal is to create a decorator `@log_calls` that logs all method calls on an instance of a class, along with their arguments. Additionally, you need to implement a metaclass `LoggingMeta` to apply this decorator to all methods in any class it creates.

```python
def log_calls(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        return func(*args, **kwargs)
    return wrapper

class LoggingMeta(type):
    # Implement this metaclass to apply the @log_calls decorator to all methods of a class.
    pass

class MyClass(metaclass=LoggingMeta):
    def method1(self, x):
        return x + 1
    
    def method2(self, y):
        return y * 2

# Usage
obj = MyClass()
result1 = obj.method1(5)
result2 = obj.method2(3)
```

Which of the following should you implement in the `LoggingMeta` metaclass to achieve the desired functionality?

A) 
```python
class LoggingMeta(type):
    def __new__(cls, name, bases, dct):
        for attr_name, attr_value in dct.items():
            if callable(attr_value):
                dct[attr_name] = log_calls(attr_value)
        return super().__new__(cls, name, bases, dct)
```

B) 
```python
class LoggingMeta(type):
    def __init__(self, name, bases, dct):
        for attr_name, attr_value in dct.items():
            if callable(attr_value):
                dct[attr_name] = log_calls(attr_value)
```

C) 
```python
class LoggingMeta(type):
    @classmethod
    def __prepare__(cls, name, bases):
        return super().__prepare__(name, bases)
    
    @classmethod
    def __new__(cls, name, bases, dct):
        for attr_name, attr_value in dct.items():
            if callable(attr_value):
                dct[attr_name] = log_calls(attr_value)
        return super().__new__(cls, name, bases, dct)
```

D) 
```python
class LoggingMeta(type):
    def __call__(self, *args, **kwargs):
        for attr_name, attr_value in self.__dict__.items():
            if callable(attr_value):
                self.__dict__[attr_name] = log_calls(attr_value)
```

**Part 2 (Answer):**

A) 
```python
class LoggingMeta(type):
    def __new__(cls, name, bases, dct):
        for attr_name, attr_value in dct.items():
            if callable(attr_value):
                dct[attr_name] = log_calls(attr_value)
        return super().__new__(cls, name, bases, dct)
```

**Explanation:**
- The `__new__` method of a metaclass is responsible for creating the class object. By overriding it, you can modify the dictionary that represents the class attributes before the class object is created.
- The code in option A correctly modifies each callable attribute in the dictionary by applying the `log_calls` decorator to them. This ensures that all methods of any class using this metaclass will be wrapped with logging functionality.

Options B, C, and D do not achieve the desired outcome because they are incorrectly attempting to apply the decorator during different stages of class creation or instance initialization. Option A is the correct approach as it properly applies the `log_calls` decorator to all methods during the class creation process.
    
    ---
    *Generated on: 2025-12-10 16:03:06*
    