# Python Quiz Question
    
    ## Question
    [QUESTION]
Consider the following Python code that attempts to create a decorator for class methods which caches their return values based on the method arguments:

```python
from functools import lru_cache

def cache_method_results(cls):
    cache_methods = set()

    def wrapper(self, *args, **kwargs):
        key = args + tuple(sorted(kwargs.items()))
        if key not in self.cache:
            result = getattr(self, method)(*args, **kwargs)
            self.cache[key] = result
        return self.cache[key]

    for attr_name, attr_value in cls.__dict__.items():
        if callable(attr_value) and not isinstance(attr_value, property):
            cache_methods.add(attr_name)
            setattr(cls, attr_name, wrapper)

    @property
    def cache(self):
        return getattr(self, "_cache", {})

    return cls

@cache_method_results
class Calculator:
    def add(self, a, b):
        return a + b
```

However, this decorator does not work as expected. Identify the issue and provide a correct implementation of the `cache_method_results` decorator.

A) The cache dictionary is not accessible within the class instances.
B) The wrapper function needs to store the cache dictionary in an instance attribute.
C) The `cache_method_results` should use `lru_cache` from functools instead of manually implementing caching logic.
D) The methods being cached are not being replaced with their cached versions.
    
    ## Answer
    [B] The wrapper function needs to store the cache dictionary in an instance attribute. 

The original implementation tries to create a class-wide cache, but it should be stored in each instance's attributes. Here is the corrected code:

```python
from functools import lru_cache

def cache_method_results(cls):
    cache_methods = set()

    def wrapper(self, *args, **kwargs):
        key = args + tuple(sorted(kwargs.items()))
        if key not in self._cache:
            result = getattr(self, method)(*args, **kwargs)
            self._cache[key] = result
        return self._cache[key]

    for attr_name, attr_value in cls.__dict__.items():
        if callable(attr_value) and not isinstance(attr_value, property):
            cache_methods.add(attr_name)
            setattr(cls, attr_name, wrapper)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._cache = {}

    cls.__init__ = __init__
    return cls

@cache_method_results
class Calculator:
    def add(self, a, b):
        return a + b
```

In this corrected version, each instance of `Calculator` has its own `_cache` dictionary to store the results of method calls.
    
    ---
    *Generated on: 2026-02-04 08:02:45*
    