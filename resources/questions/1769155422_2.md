# Python Quiz Question
    
    ## Question
    
    
    ## Answer
    **Part 1 (Question):**

You are tasked with creating a Python application that involves asynchronous operations. The application is expected to handle multiple I/O-bound tasks concurrently. Your goal is to design a system where each task can be easily added or modified without altering the main flow of execution.

Consider the following scenario:

- You have a set of functions, each representing an I/O-bound task.
- Each function takes no arguments and returns a result.
- You need to run all these tasks concurrently and collect their results.

Your solution should use Python's `asyncio` library and demonstrate proper handling of asynchronous tasks. Below is a code snippet that you can use as a starting point:

```python
import asyncio

# Example I/O-bound task function
async def fetch_data(task_id):
    print(f"Task {task_id} started")
    await asyncio.sleep(1)  # Simulate an I/O operation
    return f"Result from Task {task_id}"

# Main coroutine to run tasks concurrently and collect results
async def main():
    tasks = [fetch_data(i) for i in range(5)]
    results = await asyncio.gather(*tasks)
    print("All tasks completed. Results:", results)

# Run the event loop
if __name__ == "__main__":
    asyncio.run(main())
```

**Question:**
How would you modify the `main` coroutine to allow adding new I/O-bound task functions dynamically without changing the existing code? Provide a brief explanation of your solution.

A) Modify the `fetch_data` function to accept an additional parameter that specifies the task logic, then create a generic `run_task` function to handle all tasks.
B) Use a decorator to modify each I/O-bound task function to accept an identifier and append it to the results list.
C) Implement a metaclass that automatically registers each I/O-bound task function with a task manager class.
D) Change the `main` coroutine to accept a list of task functions as an argument and run them concurrently.

**Part 2 (Answer):**

**Correct Answer: C) Implement a metaclass that automatically registers each I/O-bound task function with a task manager class.**

**Explanation:**  
Implementing a metaclass in Python allows you to dynamically modify the behavior of a class at creation time. By creating a metaclass that registers all subclasses (i.e., I/O-bound task functions), you can centralize management and execution of these tasks. Here's an example of how you could implement this:

```python
import asyncio

# Metaclass to register I/O-bound task functions
class TaskManager(type):
    _registered_tasks = {}

    def __new__(cls, name, bases, dct):
        if 'fetch_data' in dct:
            TaskManager._registered_tasks[name] = dct['fetch_data']
        return super().__new__(cls, name, bases, dct)

# Base class for I/O-bound tasks using the metaclass
class IOBoundTask(metaclass=TaskManager):
    pass

# Example I/O-bound task function using the base class
async def fetch_data(self, task_id):
    print(f"Task {task_id} started")
    await asyncio.sleep(1)  # Simulate an I/O operation
    return f"Result from Task {task_id}"

class FetchData(IOBoundTask):
    pass

# Main coroutine to run tasks concurrently and collect results using the registered tasks
async def main():
    tasks = [FetchData().fetch_data(i) for i in range(5)]
    results = await asyncio.gather(*tasks)
    print("All tasks completed. Results:", results)

# Run the event loop
if __name__ == "__main__":
    asyncio.run(main())
```

This approach allows you to dynamically add new I/O-bound task functions by simply creating a subclass of `IOBoundTask` and defining the `fetch_data` method. The metaclass automatically registers these methods, making it easy to manage and execute them concurrently in the `main` coroutine.
    
    ---
    *Generated on: 2026-01-23 08:03:42*
    