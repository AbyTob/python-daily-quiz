# Python Quiz Question
    
    ## Question
    [QUESTION]
You are tasked with creating a class decorator that can be used to log the entry, exit, and duration of any method it decorates. The decorator should work for both synchronous and asynchronous methods.

```python
class MethodLogger:
    pass

@MethodLogger()
def sync_function():
    print("Executing sync function")

async def async_function():
    await asyncio.sleep(1)
    print("Executing async function")
```

Which of the following options correctly implements the `MethodLogger` class to achieve the described functionality?

A) Synchronous logging only:
```python
class MethodLogger:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        start_time = time.time()
        result = self.func(*args, **kwargs)
        end_time = time.time()
        print(f"Executed {self.func.__name__} in {end_time - start_time} seconds")
        return result
```

B) Asynchronous logging only:
```python
class MethodLogger:
    async def __call__(self, func):
        async def wrapper(*args, **kwargs):
            start_time = time.time()
            result = await func(*args, **kwargs)
            end_time = time.time()
            print(f"Executed {func.__name__} in {end_time - start_time} seconds")
            return result
        return wrapper
```

C) Both synchronous and asynchronous logging:
```python
class MethodLogger:
    def __init__(self, func=None):
        self.func = func

    def __call__(self, *args, **kwargs):
        if asyncio.iscoroutinefunction(self.func):
            async def wrapper(*args, **kwargs):
                start_time = time.time()
                result = await self.func(*args, **kwargs)
                end_time = time.time()
                print(f"Executed {self.func.__name__} in {end_time - start_time} seconds")
                return result
        else:
            def wrapper(*args, **kwargs):
                start_time = time.time()
                result = self.func(*args, **kwargs)
                end_time = time.time()
                print(f"Executed {self.func.__name__} in {end_time - start_time} seconds")
                return result
        return wrapper
```

D) Neither synchronous nor asynchronous logging:
```python
class MethodLogger:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        raise NotImplementedError("MethodLogger is not implemented for this method type.")
```
    
    ## Answer
    C) Both synchronous and asynchronous logging:

Explanation: The correct implementation of the `MethodLogger` class should handle both synchronous and asynchronous methods. It uses a constructor to store the function it decorates and then checks if the decorated function is an async function using `asyncio.iscoroutinefunction(self.func)`. Depending on whether the function is synchronous or async, it either uses a regular function wrapper or an async function wrapper to log the execution time before and after calling the original function.
    
    ---
    *Generated on: 2025-11-03 16:02:40*
    