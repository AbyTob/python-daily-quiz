# Python Quiz Question
    
    ## Question
    Part 1 (Question): Consider the following Python code snippet that uses a decorator to measure execution time:

```python
import time

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f}s")
        return result
    return wrapper

@timer
def compute_sum(n):
    return sum(range(n))

# Example usage:
result = compute_sum(1000000)
```

What is the purpose of using a decorator in this context, and how does it modify the behavior of the `compute_sum` function?

A) It increases the execution time of the `compute_sum` function.

B) It provides a way to measure and print the time taken by the `compute_sum` function when called.

C) It changes the return type of the `compute_sum` function.

D) It prevents any output from being printed during the function call.
    
    ## Answer
    Part 2 (Answer): B) It provides a way to measure and print the time taken by the `compute_sum` function when called.

Explanation: The decorator `@timer` is used to add functionality to an existing function without modifying its structure. In this case, it measures the execution time of the `compute_sum` function each time it is called. When `compute_sum(1000000)` is executed, it not only calculates the sum of numbers from 0 to 999999 but also prints out how long the computation took. The decorator wraps the original function and adds timing logic around it, demonstrating a practical use of decorators for performance monitoring.
    
    ---
    *Generated on: 2025-09-29 00:01:47*
    