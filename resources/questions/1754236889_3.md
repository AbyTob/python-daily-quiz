# Python Quiz Question
    
    ## Question
    Part 1 (Question):
Consider the following code:

```python
import asyncio

def async_decorator(func):
    def wrapper(*args, **kwargs):
        return asyncio.run(func(*args, **kwargs))
    return wrapper

@async_decorator
async def fetch_data():
    await asyncio.sleep(1)
    return "Data fetched"

async def main():
    result = fetch_data()
    print(result)

# Run the program using asyncio.run(main())
```

Which of the following statements is true about the `fetch_data` function when decorated with `@async_decorator`?

A) It returns a coroutine directly.
B) The decorator converts it into a synchronous function.
C) It executes synchronously and blocks while waiting for the sleep to complete.
D) It runs asynchronously and completes in 1 second.
    
    ## Answer
    Part 2 (Answer):
C) It executes synchronously and blocks while waiting for the sleep to complete.

Explanation:
When `fetch_data` is decorated with `@async_decorator`, it is wrapped by a function that schedules its execution using `asyncio.run(func(*args, **kwargs))`. This means that calling `fetch_data()` directly will not return a coroutine but will instead block until the asynchronous operation completes. The correct behavior here is synchronous execution due to the decorator, making option C the only accurate statement about the decorated function's behavior.
    
    ---
    *Generated on: 2025-08-03 16:01:29*
    