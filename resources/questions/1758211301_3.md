# Python Quiz Question
    
    ## Question
    [QUESTION]  
Consider the following Python code that uses both decorators and metaclasses:

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Something is happening before the function is called.")
        result = func(*args, **kwargs)
        print("Something is happening after the function is called.")
        return result
    return wrapper

class Meta(type):
    def __new__(cls, name, bases, dct):
        if 'my_method' in dct:
            dct['my_method'] = my_decorator(dct['my_method'])
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=Meta):
    def my_method(self):
        print("Executing my_method.")

# Usage
obj = MyClass()
obj.my_method()
```

What will be the output of running `MyClass().my_method()`?

A)  
Something is happening before the function is called.  
Executing my_method.  
Something is happening after the function is called.

B)  
Something is happening before the function is called.  
Something is happening after the function is called.  

C)  
Executing my_method.  

D)  
Error
    
    ## Answer
    A) Something is happening before the function is called.  
Executing my_method.  
Something is happening after the function is called.

Explanation: The metaclass `Meta` decorates the method `my_method` with the decorator `my_decorator`. When an instance of `MyClass` is created and `my_method` is called, the decorated version of `my_method` executes first, printing the pre-call message, then the actual method logic, and finally the post-call message.
    
    ---
    *Generated on: 2025-09-18 16:01:41*
    