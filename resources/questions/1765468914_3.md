# Python Quiz Question
    
    ## Question
    [QUESTION]
Consider the following code snippet:

```python
import asyncio

async def async_task():
    print("Task started")
    await asyncio.sleep(1)
    print("Task finished")

def sync_wrapper(func):
    async def wrapper(*args, **kwargs):
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, func, *args, **kwargs)
    return wrapper

@sync_wrapper
async def main():
    task = asyncio.create_task(async_task())
    print("Main function started")
    await task
    print("Main function finished")

if __name__ == "__main__":
    asyncio.run(main())
```

What will be the output of this code when run? 

A) Task started, Main function started, Task finished, Main function finished  
B) Main function started, Task started, Main function finished, Task finished  
C) Task started, Main function started, Task finished  
D) Main function started, Task started, Task finished, Main function finished
    
    ## Answer
    A) Task started, Main function started, Task finished, Main function finished  

**Explanation:** The `sync_wrapper` decorator is intended to run synchronous functions asynchronously using `asyncio`. However, in the provided code, it mistakenly tries to use `run_in_executor` on an already asynchronous function `async_task`, which leads to unexpected behavior. Since `async_task` is already a coroutine, calling it directly without awaiting it inside the wrapper function will not yield control back to the event loop and thus, it does not print "Task finished" before moving on to "Main function finished". Instead, the output will be the same as option A because both print statements in `main` are executed immediately, followed by the awaits of the task.
    
    ---
    *Generated on: 2025-12-11 16:01:54*
    