# Python Quiz Question
    
    ## Question
    [QUESTION]
Consider the following Python code:

```python
import threading

def thread_safe(func):
    def wrapper(*args, **kwargs):
        with threading.Lock():
            return func(*args, **kwargs)
    return wrapper

@thread_safe
class Counter:
    def __init__(self):
        self.value = 0

    def increment(self):
        self.value += 1

    def get_value(self):
        return self.value

def run_counter():
    counter = Counter()
    threads = []
    for _ in range(1000):
        thread = threading.Thread(target=counter.increment)
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    print(f"Final value: {counter.get_value()}")

if __name__ == "__main__":
    run_counter()
```

What issue might arise with the execution of this code and how can it be fixed?

A) The counter will always display a final value of 1000.
B) The `thread_safe` decorator does not effectively lock access to the Counter's methods.
C) A memory leak will occur due to improper thread management.
D) The program will hang indefinitely.
    
    ## Answer
    [B] The `thread_safe` decorator does not effectively lock access to the Counter's methods. 

The issue with the code is that while each method of the `Counter` class is decorated with `@thread_safe`, this means that every call to `increment`, `get_value`, and other methods will be protected by a lock within each thread individually. However, the `Counter` instance itself is not thread-safe because there's no synchronization between different threads accessing the same instance.

To fix this issue, you should ensure that all operations on the shared resource (`self.value`) are protected by a single lock across all threads. This can be achieved by moving the lock to the `Counter` class level instead of decorating each method individually:

```python
import threading

class ThreadSafeCounter:
    def __init__(self):
        self.value = 0
        self.lock = threading.Lock()

    def increment(self):
        with self.lock:
            self.value += 1

    def get_value(self):
        with self.lock:
            return self.value

def run_counter():
    counter = ThreadSafeCounter()
    threads = []
    for _ in range(1000):
        thread = threading.Thread(target=counter.increment)
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    print(f"Final value: {counter.get_value()}")

if __name__ == "__main__":
    run_counter()
```

By using a class-level lock, you ensure that all operations on the `Counter` instance are synchronized, preventing race conditions and ensuring that the final value displayed is 1000.
    
    ---
    *Generated on: 2025-12-18 16:02:51*
    