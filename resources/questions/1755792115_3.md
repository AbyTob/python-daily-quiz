# Python Quiz Question
    
    ## Question
    Part 1 (Question):
Consider the following Python code:

```python
import asyncio

class AsyncDecorator:
    def __init__(self, func):
        self.func = func

    async def __call__(self, *args, **kwargs):
        return await self.func(*args, **kwargs)

@AsyncDecorator
async def fetch_data():
    print("Fetching data...")
    await asyncio.sleep(1)
    print("Data fetched!")
    return "data"

async def main():
    result = await fetch_data()
    print(result)

# Run the example
asyncio.run(main())
```

Which of the following statements is true regarding the code above?

A) The `AsyncDecorator` class converts a synchronous function into an asynchronous one.
B) When `fetch_data()` is called, it will execute immediately without waiting for the sleep to finish.
C) The `__call__` method of `AsyncDecorator` ensures that the wrapped function returns an awaitable object.
D) The `asyncio.run(main())` call will run the `main()` coroutine and print "data" after a 1-second delay.
    
    ## Answer
    Part 2 (Answer):
C) The `__call__` method of `AsyncDecorator` ensures that the wrapped function returns an awaitable object.

Explanation: In this code, `AsyncDecorator` is used to convert any synchronous function into an asynchronous one. When you decorate a function with `@AsyncDecorator`, it wraps the original function in an instance of `AsyncDecorator`. The `__call__` method is overridden in this class to make sure that when the decorated function is called, it returns an awaitable object, allowing it to be awaited using `await`.

Option A is incorrect because `fetch_data()` is already defined as an asynchronous function. Option B is incorrect because calling `await fetch_data()` will pause execution of `main()` until `fetch_data()` completes. Option D is correct in that running `asyncio.run(main())` will indeed execute the `main()` coroutine and print "data" after a 1-second delay.
    
    ---
    *Generated on: 2025-08-21 16:01:55*
    