# Python Quiz Question
    
    ## Question
    **Part 1 (Question):**

Consider the following Python code snippet that uses decorators, metaclasses, and asyncio:

```python
import asyncio

class Meta(type):
    def __new__(cls, name, bases, dct):
        # Decorate all methods in the class with a simple logging decorator
        for key, value in dct.items():
            if callable(value):
                dct[key] = cls.log_decorator(value)
        return super().__new__(cls, name, bases, dct)

    @staticmethod
    def log_decorator(func):
        async def wrapper(*args, **kwargs):
            print(f"Calling {func.__name__}")
            result = await func(*args, **kwargs)
            print(f"{func.__name__} returned {result}")
            return result
        return wrapper

class MyClass(metaclass=Meta):
    async def my_method(self, x):
        return x * 2

async def main():
    obj = MyClass()
    await obj.my_method(3)

if __name__ == "__main__":
    asyncio.run(main())
```

What will be the output of this script?

A) Error: MetaClass does not support async methods  
B) Calling my_method  
   my_method returned 6  
C) Error: Decorator cannot handle asynchronous functions  
D) None
    
    ## Answer
    **Part 2 (Answer):**

**Correct Answer:** B  
**Explanation:** The provided code uses a metaclass `Meta` to decorate all callable methods within the class `MyClass`. The `log_decorator` method is designed to log the name of the function being called and its return value. However, when defining an asynchronous method in Python, it must be explicitly declared as such with the `async def` syntax. In the given code, `my_method` is correctly defined as `async def`, which means that it can be awaited properly within other asynchronous functions like `main()`. The metaclass successfully decorates this method and logs the call, returning the expected output:

```
Calling my_method
my_method returned 6
```
    
    ---
    *Generated on: 2026-01-30 00:02:07*
    