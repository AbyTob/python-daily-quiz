# Python Quiz Question
    
    ## Question
    [QUESTION]
**Question:** Consider the following Python code that uses a decorator to log method calls of a class. Your task is to understand how decorators work in this context and analyze its impact on performance.

```python
import functools

def log_calls(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned {result}")
        return result
    return wrapper

class Calculator:
    @log_calls
    def add(self, a, b):
        return a + b
    
    @log_calls
    def multiply(self, a, b):
        return a * b
```

Now, consider the following usage of the `Calculator` class:

```python
calc = Calculator()
result1 = calc.add(3, 4)
result2 = calc.multiply(5, 6)
```

**What is the impact of using the `log_calls` decorator on performance when calling methods of the `Calculator` class?**

A) The performance degradation is negligible as logging is fast.

B) The performance can significantly degrade due to increased overhead from method calls and prints.

C) Using decorators for logging does not affect performance at all.

D) It depends on the complexity of the decorated functions.
    
    ## Answer
    **Answer:** B) The performance can significantly degrade due to increased overhead from method calls and prints.

**Explanation:** Decorators add additional code (in this case, logging statements) around the original function. This adds extra steps to the execution process:
1. Function call resolution.
2. Wrapper function invocation.
3. Argument passing to the wrapper.
4. Printing the log messages.
5. Returning from the wrapper and the original function.

These extra steps can introduce noticeable performance overhead, especially if the decorated functions are called frequently or involve complex operations. The impact is more pronounced if the logging involves I/O operations like printing to a file, as these are inherently slower than simple memory operations performed during function execution.
    
    ---
    *Generated on: 2025-08-27 16:02:01*
    