# Python Quiz Question
    
    ## Question
    [QUESTION]
Consider the following Python code that uses a decorator to add logging functionality to a class method:

```python
import functools

def log_method_calls(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args[1:]}, kwargs: {kwargs}")
        return func(*args, **kwargs)
    return wrapper

class MyClass:
    @log_method_calls
    def my_method(self, a, b=2):
        return a + b

# Usage
obj = MyClass()
result = obj.my_method(3)
```

Which of the following statements is true regarding this code?

A) The `@functools.wraps(func)` decorator preserves the metadata of `func`, such as its name and docstring.
B) When calling `obj.my_method(3)`, the output will be "Calling my_method with args: (3,), kwargs: {}" followed by the return value of `my_method`.
C) The `wrapper` function does not have access to any local variables of `my_method`.
D) All method calls on instances of `MyClass` are automatically logged.
    
    ## Answer
    A) The `@functools.wraps(func)` decorator preserves the metadata of `func`, such as its name and docstring.

Explanation:
- Option A is correct. The `@functools.wraps(func)` decorator is used to preserve the identity of the original function, including its name, docstring, etc.
- Option B is incorrect because `my_method` has a default argument (`b=2`), so calling `obj.my_method(3)` will log the arguments as "Calling my_method with args: (3,), kwargs: {}" but will not show the default value of `b`.
- Option C is incorrect. The `wrapper` function does have access to the local variables of `my_method` through the closure mechanism.
- Option D is incorrect. Only method calls explicitly decorated with `@log_method_calls` are logged; other method calls on instances of `MyClass` will not be automatically logged.
    
    ---
    *Generated on: 2025-11-07 00:02:05*
    