# Python Quiz Question
    
    ## Question
    
    
    ## Answer
    **Part 1 (Question):**

Consider the following Python code snippet that uses both metaclasses and decorators:

```python
from functools import wraps

def log_method_calls(cls):
    for name, value in cls.__dict__.items():
        if callable(value) and not name.startswith('__'):
            setattr(cls, name, log_call(value))
    return cls

class Meta(type):
    def __new__(cls, name, bases, dct):
        dct['log_info'] = lambda self: f"{name} instance created"
        return super().__new__(cls, name, bases, dct)

@log_method_calls
class MyClass(metaclass=Meta):
    def method1(self):
        print("Method 1 called")

    def method2(self):
        print("Method 2 called")
```

What will be printed when the following code is executed?

```python
obj = MyClass()
print(obj.method1())
print(obj.method2())
print(obj.log_info())
```

A) Method 1 called  
   Method 2 called  
   MyClass instance created  

B) Method 1 called  
   Method 2 called  
   MyInstance instance created  

C) AttributeError: 'MyClass' object has no attribute 'log_method_calls'

D) TypeError: 'log_method_calls' is not callable

**Part 2 (Answer):**

A) Method 1 called  
   Method 2 called  
   MyClass instance created  

Explanation:
- The `Meta` metaclass adds a `log_info` method to any class that uses it.
- The `@log_method_calls` decorator wraps each method in the class, adding logging functionality by using the `log_call` wrapper function.
- When an instance of `MyClass` is created, the `__new__` method of `Meta` is called, setting up the `log_info` method.
- When `method1()` and `method2()` are called on an instance of `MyClass`, the logs added by `@log_method_calls` are printed first, followed by the actual method call output.
- Finally, calling `obj.log_info()` results in the string "MyClass instance created" being printed, demonstrating how the metaclass method is accessible through instances of `MyClass`.
    
    ---
    *Generated on: 2026-01-09 16:02:22*
    