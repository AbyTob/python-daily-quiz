# Python Quiz Question
    
    ## Question
    [QUESTION]
Consider the following Python code snippet:

```python
import threading

def thread_safe(class_):
    class ThreadSafeClass:
        def __init__(self, *args, **kwargs):
            self._instance = None
            self.lock = threading.Lock()
            
        def __call__(self, *args, **kwargs):
            if not self._instance:
                with self.lock:
                    if not self._instance:
                        self._instance = class_(*args, **kwargs)
            return self._instance
        
    return ThreadSafeClass

@thread_safe
class Singleton:
    def __init__(self):
        self.data = []

    def add_data(self, item):
        self.data.append(item)

def main():
    singleton1 = Singleton()
    singleton2 = Singleton()

    thread1 = threading.Thread(target=singleton1.add_data, args=(1,))
    thread2 = threading.Thread(target=singleton2.add_data, args=(2,))

    thread1.start()
    thread2.start()

    thread1.join()
    thread2.join()

    print(singleton1.data)

if __name__ == "__main__":
    main()
```

Which of the following statements correctly describes the behavior of this code when run in a multi-threaded environment?

A) The output will always be `[1, 2]` because `Singleton` is decorated with `thread_safe`.

B) The output could be either `[1]` or `[2]` depending on the order of thread execution.

C) The output will be an error because accessing shared resources without locking is not allowed in Python.

D) The output will always be `[1]` because the `Singleton` class is not properly implemented as a singleton.
    
    ## Answer
    B) The output could be either `[1]` or `[2]` depending on the order of thread execution.
    
    ---
    *Generated on: 2026-02-02 08:02:05*
    