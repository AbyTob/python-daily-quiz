# Python Quiz Question
    
    ## Question
    [QUESTION]
Consider the following Python code that aims to create a decorator for logging function calls. However, it encounters an issue when applied to asynchronous functions:

```python
import functools

def log_decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@log_decorator
async def async_function(x):
    await asyncio.sleep(1)
    return x * 2

# Usage example
import asyncio
result = asyncio.run(async_function(5))
print(result)
```

When you run this code, it results in a `TypeError`. Identify the issue and correct it so that the decorator works with asynchronous functions.

A) The `wrapper` function needs to be made asynchronous.
B) The `@functools.wraps(func)` should be removed.
C) The decorator is not needed for asynchronous functions.
D) The `asyncio.sleep(1)` inside the `async_function` is unnecessary.
    
    ## Answer
    [A] The `wrapper` function needs to be made asynchronous.

Explanation: When a decorator is applied to an asynchronous function, both the decorator and the wrapped function need to be asynchronous. In the original code, only the decorator was defined as synchronous, causing a type mismatch when calling it with an asynchronous function. By making the wrapper coroutine using `async def`, we ensure that the types are compatible, allowing the decorator to work correctly with asynchronous functions.
    
    ---
    *Generated on: 2026-02-16 16:01:45*
    