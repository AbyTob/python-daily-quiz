# Python Quiz Question
    
    ## Question
    [QUESTION]
Consider the following code that attempts to use a metaclass to enforce type constraints on class attributes:

```python
class TypeConstraint(type):
    def __new__(cls, name, bases, dct):
        for attr, value in dct.items():
            if not isinstance(value, int):
                raise TypeError(f"{attr} must be an integer")
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=TypeConstraint):
    a = 1
    b = 'string'  # This should trigger the error

if __name__ == "__main__":
    obj = MyClass()
```

What will happen when you run this code? Explain your answer.

A) It will successfully create an instance of `MyClass`.
B) A `TypeError` will be raised because `b` is not an integer.
C) The program will hang indefinitely.
D) It will create a class with attributes `a` and `b`, but `b` will be ignored.
    
    ## Answer
    B) A `TypeError` will be raised because `b` is not an integer.

Explanation: When the metaclass `TypeConstraint` tries to create the class `MyClass`, it checks each attribute of the class dictionary. Since `b` is a string, the condition in the `for` loop fails for this attribute, and a `TypeError` is raised before any instance of `MyClass` can be created. This demonstrates how metaclasses can enforce type constraints at class creation time.
    
    ---
    *Generated on: 2025-12-29 08:01:51*
    