# Python Quiz Question
    
    ## Question
    ### Part 1 (Question)

Consider the following Python code that uses decorators and metaclasses together. The goal is to create a decorator that can be used to log the arguments with which an instance method is called.

```python
class MethodLoggerMeta(type):
    def __new__(cls, name, bases, dct):
        for attr_name, attr in dct.items():
            if callable(attr) and not attr_name.startswith('__'):
                dct[attr_name] = cls._create_logged_method(attr)
        return super().__new__(cls, name, bases, dct)

    @staticmethod
    def _create_logged_method(func):
        def wrapper(self, *args, **kwargs):
            print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
            return func(self, *args, **kwargs)
        return wrapper

@MethodLoggerMeta
class MyClass:
    def method1(self, a, b):
        return a + b

    def method2(self, x):
        return x * 3
```

Which of the following statements correctly describes how to use this class and what output you would expect?

A) Creating an instance of `MyClass` and calling its methods will log the arguments but not change their behavior.

B) Creating an instance of `MyClass` and calling its methods will both log the arguments and execute the original method's functionality.

C) Calling a non-method attribute on an instance of `MyClass` will raise an AttributeError.

D) The metaclass does not affect the functionality of the class at all, only its instantiation.
    
    ## Answer
    ### Part 2 (Answer)

B) Creating an instance of `MyClass` and calling its methods will both log the arguments and execute the original method's functionality.

Explanation:
- The `MethodLoggerMeta` metaclass dynamically wraps each callable attribute (method) in a logging wrapper. This means that every time any method is called on an instance of `MyClass`, it first prints out the arguments passed to it, and then proceeds to execute the original method.
- Option A is incorrect because although the methods are logged, their actual functionality is preserved.
- Option C is incorrect because the metaclass does not affect non-method attributes.
- Option D is incorrect because the metaclass clearly modifies the behavior of the class by wrapping its methods.
    
    ---
    *Generated on: 2025-12-20 16:02:48*
    