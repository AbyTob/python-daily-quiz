# Python Quiz Question
    
    ## Question
    **Part 1 (Question):**

Implement a context manager that measures the execution time of any block of code it decorates. Your implementation should use Python's `time` module to calculate the duration in seconds. 

Here is an initial draft of such a context manager:

```python
import time

class ExecutionTimer:
    def __enter__(self):
        self.start = time.time()
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        end = time.time()
        print(f"Execution took {end - self.start} seconds")
        return False  # Propagate exceptions if any

# Example usage:
@ExecutionTimer()
def some_function():
    for i in range(10**7):
        pass
```

However, the above implementation has a flaw. It only measures the execution time of the function when it is used as a decorator (using `@` syntax), but not when used as a context manager.

Correct this implementation so that it works both as a decorator and a context manager.

A) [Incorrect] The code already works correctly for both decorators and context managers.
B) [Incorrect] Change the `__exit__` method to calculate time only if an exception occurred.
C) [Correct] Modify the class to accept a function and return a new function when used as a decorator, while keeping the existing functionality when used as a context manager.
D) [Incorrect] Use the `with` statement inside the `__enter__` method to measure execution time.

**Part 2 (Answer):**

C) Modify the class to accept a function and return a new function when used as a decorator, while keeping the existing functionality when used as a context manager.

Explanation:
The current implementation only works correctly when used as a decorator. To make it work both ways, we need to modify `ExecutionTimer` so that it can be instantiated as a class or called as a decorator depending on its usage. 

Here is how you could implement this:

```python
import time

class ExecutionTimer:
    def __init__(self):
        self.start = None
    
    def __call__(self, func):
        # Decorator case
        def wrapper(*args, **kwargs):
            start = time.time()
            result = func(*args, **kwargs)
            end = time.time()
            print(f"Execution of {func.__name__} took {end - start} seconds")
            return result
        return wrapper
    
    def __enter__(self):
        self.start = time.time()
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        end = time.time()
        print(f"Execution took {end - self.start} seconds")
        return False  # Propagate exceptions if any

# Example usage as decorator:
@ExecutionTimer()
def some_function():
    for i in range(10**7):
        pass

# Example usage as context manager:
with ExecutionTimer() as timer:
    another_function = lambda: sum(range(10**6))
    another_function()
```

This implementation allows `ExecutionTimer` to be used both as a decorator and a context manager, making it more versatile and useful in various scenarios.
    
    ## Answer
    Answer format error. Please check the generated content.
    
    ---
    *Generated on: 2025-11-16 00:02:52*
    