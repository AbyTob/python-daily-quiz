# Python Quiz Question
    
    ## Question
    [QUESTION]
You are tasked with creating a Python application that needs to track the execution time of various functions. You decide to implement this functionality using decorators. However, you want to ensure that the decorator can handle both synchronous and asynchronous functions seamlessly.

Design a metaclass `TimingMeta` that allows you to decorate both synchronous and asynchronous functions. The metaclass should automatically apply an appropriate timing function based on whether the decorated method is synchronous or asynchronous.

Here's a starting point for the `TimingMeta` class:

```python
import time
from asyncio import get_event_loop, iscoroutinefunction

class TimingMeta(type):
    def __new__(cls, name, bases, dct):
        # Your implementation goes here
        return super().__new__(cls, name, bases, dct)
```

You need to complete the `__new__` method of `TimingMeta` so that it applies different timing decorators to synchronous and asynchronous methods. The synchronous method should use a simple decorator that measures execution time, while the asynchronous method should use an asynchronous decorator.

Which of the following options correctly completes the `__new__` method?

A)
```python
def sync_timer(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time} seconds to execute")
        return result
    return wrapper

def async_timer(func):
    async def wrapper(*args, **kwargs):
        loop = get_event_loop()
        start_time = time.time()
        result = await func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time} seconds to execute")
        return result
    return wrapper

def apply_timer(func):
    if iscoroutinefunction(func):
        return async_timer(func)
    else:
        return sync_timer(func)

class TimingMeta(type):
    def __new__(cls, name, bases, dct):
        for attr_name, attr_value in dct.items():
            if callable(attr_value):
                dct[attr_name] = apply_timer(attr_value)
        return super().__new__(cls, name, bases, dct)
```

B) 
```python
def sync_timer(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time} seconds to execute")
        return result
    return wrapper

def apply_timer(func):
    return sync_timer(func)

class TimingMeta(type):
    def __new__(cls, name, bases, dct):
        for attr_name, attr_value in dct.items():
            if callable(attr_value):
                dct[attr_name] = apply_timer(attr_value)
        return super().__new__(cls, name, bases, dct)
```

C)
```python
def sync_timer(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time} seconds to execute")
        return result
    return wrapper

def async_timer(func):
    async def wrapper(*args, **kwargs):
        loop = get_event_loop()
        start_time = time.time()
        result = await func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time} seconds to execute")
        return result
    return wrapper

def apply_timer(func):
    if iscoroutinefunction(func):
        return async_timer(func)
    else:
        return sync_timer(func)

class TimingMeta(type):
    def __new__(cls, name, bases, dct):
        for attr_name, attr_value in dct.items():
            if callable(attr_value):
                setattr(dct, attr_name, apply_timer(attr_value))
        return super().__new__(cls, name, bases, dct)
```

D) 
```python
def sync_timer(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time} seconds to execute")
        return result
    return wrapper

def apply_timer(func):
    return sync_timer(func)

class TimingMeta(type):
    def __new__(cls, name, bases, dct):
        for attr_name, attr_value in dct.items():
            if callable(attr_value):
                setattr(dct, attr_name, apply_timer(attr_value))
        return super().__new__(cls, name, bases, dct)
```
    
    ## Answer
    A) is the correct answer.

Explanation:
- Option A correctly implements a metaclass `TimingMeta` that dynamically applies the appropriate timing decorator (`sync_timer` or `async_timer`) to both synchronous and asynchronous methods. It uses `iscoroutinefunction` to check if a method is an async function, then it returns the corresponding timer wrapper.
- Option B only applies the synchronous timer to all methods regardless of whether they are async or not. This will cause errors when trying to call an async method with the sync timer decorator.
- Option C incorrectly uses `setattr(dct, attr_name, apply_timer(attr_value))` instead of assigning it back directly in the dictionary. This will not work as intended because `dct` is a local variable and changes made to it won't affect the original class dictionary.
- Option D also tries to use `setattr(dct, attr_name, apply_timer(attr_value))`, which is incorrect for the same reason as option C.
    
    ---
    *Generated on: 2025-11-09 16:04:39*
    