# Python Quiz Question
    
    ## Question
    [ANSWER_SEPARATOR]
**Part 1 (Question):**

Consider the following Python code that uses a decorator to track the number of times a function is called:

```python
from functools import wraps

def call_counter(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        wrapper.count += 1
        return func(*args, **kwargs)
    wrapper.count = 0
    return wrapper

@call_counter
def add(a, b):
    return a + b

class Counter:
    def __init__(self):
        self._counts = {}

    def __call__(self, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            name = func.__name__
            if name not in self._counts:
                self._counts[name] = 0
            self._counts[name] += 1
            return func(*args, **kwargs)
        return wrapper

counter = Counter()
@counter
def subtract(a, b):
    return a - b
```

What is the output of the following code snippet?

```python
print(add(1, 2))
print(subtract(5, 3))
print(counter._counts['subtract'])
print(call_counter.count)
```

A) 3, 2, 1, 0  
B) 3, 2, 1, 1  
C) 3, 2, 1, 2  
D) 3, 2, 1, AttributeError

[ANSWER_SEPARATOR]
**Part 2 (Answer):**

B) 3, 2, 1, 1

Explanation:
- The `add` function is decorated with the `call_counter` decorator. Each time `add(1, 2)` is called, its count in `call_counter.count` increases by one.
- The `subtract` function is decorated with an instance of the `Counter` class. This instance maintains a dictionary `_counts` where each key is a function name and the value is the number of times that function has been called.
- When `subtract(5, 3)` is called for the first time, its count in `counter._counts['subtract']` increases to one.
- Since `call_counter` does not track counts across different decorated functions, `call_counter.count` remains at zero after both `add` and `subtract` have been called.
    
    ## Answer
    Answer format error. Please check the generated content.
    
    ---
    *Generated on: 2026-02-07 08:02:16*
    