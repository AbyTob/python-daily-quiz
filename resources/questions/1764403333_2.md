# Python Quiz Question
    
    ## Question
    
    
    ## Answer
    **Part 1 (Question):**

Consider the following Python code that attempts to create a decorator to log function call details, but it doesn't work as expected:

```python
import functools

def log_function_calls(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        return func(*args, **kwargs)
    return functools.wraps(func)(wrapper)

@log_function_calls
class MyClass:
    def method1(self, a):
        pass

    def method2(self, b, c=0):
        pass
```

Upon using `MyClass` and calling its methods, the decorator doesn't log the calls correctly. Identify what is wrong with this code.

A) The `wrapper` function is not properly defined to handle class methods.
B) The `functools.wraps(func)` call is misplaced in the decorator definition.
C) Using a decorator on a class method does not work in Python.
D) None of the above

**Part 2 (Answer):**

A) The correct answer is A. The issue with the code lies in how `wrapper` is defined to handle class methods. In Python, instance methods expect their first argument to be the instance itself (usually named `self`). Therefore, the `wrapper` function must also accept an additional parameter for the instance, typically named `self`.

To fix this, you should modify the wrapper to accept all arguments and pass them correctly:

```python
@log_function_calls
class MyClass:
    def method1(self, a):
        pass

    def method2(self, b, c=0):
        pass
```

However, if we want to keep the decorator's simplicity while ensuring it works with class methods, we can modify the `wrapper` function as follows:

```python
def log_function_calls(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        instance = args[0]  # Assuming the first argument is always 'self'
        print(f"Calling {func.__name__} on {instance} with args: {args[1:]}, kwargs: {kwargs}")
        return func(*args, **kwargs)
    return wrapper
```

This modification ensures that the `wrapper` function can handle both standalone functions and class methods correctly, logging the calls as expected.
    
    ---
    *Generated on: 2025-11-29 08:02:13*
    