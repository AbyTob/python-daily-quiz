# Python Quiz Question
    
    ## Question
    
    
    ## Answer
    **Question:** Consider the following Python code that attempts to create a decorator for a coroutine function to ensure it only runs once. However, it does not work as expected. Identify what is wrong with the code and provide a corrected version of the decorator.

```python
def single_run_coroutine(func):
    has_run = False
    
    async def wrapper(*args, **kwargs):
        nonlocal has_run
        if not has_run:
            await func(*args, **kwargs)
            has_run = True
        else:
            print("Coroutine already run")
    
    return wrapper

@single_run_coroutine
async def my_coroutine():
    print("Running coroutine")

# Example usage
import asyncio

loop = asyncio.get_event_loop()
loop.run_until_complete(my_coroutine())
loop.run_until_complete(my_coroutine())
```

A. The decorator does not properly handle the asynchronous context of `func`.  
B. There is no need for a nonlocal variable `has_run` inside the wrapper.  
C. The decorator should return an instance method instead of a coroutine function.  
D. The usage of `nonlocal` is incorrect in this context.

**Answer:** A. The decorator does not properly handle the asynchronous context of `func`.

**Explanation:** The issue with the original code is that it attempts to use `await` outside of an asynchronous function. In Python, `await` can only be used inside functions marked as `async`. To fix this, the wrapper itself should be defined as an `async def`. Here's the corrected version:

```python
def single_run_coroutine(func):
    has_run = False
    
    async def wrapper(*args, **kwargs):
        nonlocal has_run
        if not has_run:
            await func(*args, **kwargs)
            has_run = True
        else:
            print("Coroutine already run")
    
    return wrapper

@single_run_coroutine
async def my_coroutine():
    print("Running coroutine")

# Example usage
import asyncio

loop = asyncio.get_event_loop()
loop.run_until_complete(my_coroutine())
loop.run_until_complete(my_coroutine())  # This will correctly print "Coroutine already run"
```
    
    ---
    *Generated on: 2025-09-18 08:02:01*
    