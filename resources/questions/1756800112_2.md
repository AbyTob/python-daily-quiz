# Python Quiz Question
    
    ## Question
    **Part 1 (Question):**

Consider the following Python code that uses a metaclass to dynamically add methods to a class:

```python
class MethodAdder(type):
    def __new__(cls, name, bases, dct):
        if 'add_method' not in dct:
            dct['add_method'] = cls.add_method
        return super().__new__(cls, name, bases, dct)

    @staticmethod
    def add_method(cls, method_name, func):
        setattr(cls, method_name, staticmethod(func))

class MyClass(metaclass=MethodAdder):
    pass

def my_new_method():
    print("New method called")

MyClass.add_method(MyClass, 'new_method', my_new_method)
```

Which of the following statements correctly describes what happens when `MyClass.new_method()` is called?

A) It raises an AttributeError because 'new_method' has not been added to MyClass.

B) It prints "New method called" as expected.

C) It executes a function defined outside of MyClass but does not print anything.

D) It causes an infinite recursion due to improper use of the metaclass.
    
    ## Answer
    **Part 2 (Answer):**

**Correct Answer: B) It prints "New method called" as expected.**

**Explanation:** The `MethodAdder` metaclass dynamically adds a method named `add_method` to any class that uses it. This method can be used to add new methods to the class at runtime. In the provided code, `MyClass.add_method(MyClass, 'new_method', my_new_method)` is called, which adds `my_new_method` as an attribute of `MyClass`. When `MyClass.new_method()` is then invoked, it executes the `my_new_method` function and prints "New method called". The metaclass ensures that `add_method` is available in every class using this metaclass, allowing for flexible and dynamic method addition.
    
    ---
    *Generated on: 2025-09-02 08:01:52*
    