# Python Quiz Question
    
    ## Question
    **Part 1 (Question):**

Consider the following Python code snippet:

```python
import asyncio

async def fetch_data():
    await asyncio.sleep(1)
    return "Data fetched"

async def process_data(data):
    print(f"Processing {data}")
    await asyncio.sleep(0.5)

async def main():
    data = await fetch_data()
    tasks = [process_data(data) for _ in range(3)]
    await asyncio.gather(*tasks)

# Run the async function
asyncio.run(main())
```

Which of the following statements correctly describes the behavior of this code?

A) The `fetch_data` coroutine will execute immediately, and each call to `process_data` will start processing data fetched by `fetch_data`.

B) All three calls to `process_data` will start executing immediately after `fetch_data` returns, and they will all complete simultaneously.

C) The first call to `process_data` starts executing right away. Subsequent calls to `process_data` are scheduled but do not start until the previous call completes.

D) The code will raise an error because `asyncio.sleep(0.5)` cannot be awaited within a non-async function.
    
    ## Answer
    **Part 2 (Answer):**

C) The first call to `process_data` starts executing right away. Subsequent calls to `process_data` are scheduled but do not start until the previous call completes.

Explanation: In the provided code, `main()` is an asynchronous function that awaits the result of `fetch_data()`. It then creates a list of three tasks by calling `process_data(data)` for each element in the range (3). When you pass these tasks to `asyncio.gather(*tasks)`, it schedules all the tasks concurrently but does not run them simultaneously. Instead, it runs them in the order they were added to the gatherer object, which means the first call to `process_data` starts immediately after `fetch_data` returns. Each subsequent call is scheduled after the previous one completes.
    
    ---
    *Generated on: 2025-11-22 08:01:55*
    