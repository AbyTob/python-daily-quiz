# Python Quiz Question
    
    ## Question
    ### Part 1 (Question)
Consider the following Python code:

```python
import asyncio

def timer(func):
    async def wrapper(*args, **kwargs):
        start_time = asyncio.get_running_loop().time()
        result = await func(*args, **kwargs)
        end_time = asyncio.get_running_loop().time()
        print(f"Execution time: {end_time - start_time}")
        return result
    return wrapper

@timer
async def compute_sum(n):
    total = 0
    for i in range(n):
        total += i
    return total

async def main():
    await compute_sum(1000000)

# Run the code and observe the output.
```

**Question:** How can you modify the `timer` decorator to make it compatible with both synchronous and asynchronous functions, while still being able to measure the execution time accurately?

A) Use a simple `if-else` statement inside the decorator to check if the function is async or not.

B) Utilize Python's built-in `time` module instead of `asyncio.get_running_loop().time()` for measuring time.

C) Create two separate decorators, one for synchronous functions and another for asynchronous functions.

D) Use a context manager within the decorator to measure both synchronous and asynchronous function execution times.

### Part 2 (Answer)
**
    
    ## Answer
    ** D

**Explanation:** The correct answer is D. To create a versatile decorator that can measure the execution time of both synchronous and asynchronous functions, you should use a context manager. This approach allows you to handle both types of functions uniformly. A context manager provides an easy way to wrap your code with setup and teardown logic, which is ideal for measuring execution times.

Here's how you could modify the `timer` decorator using a context manager:

```python
import asyncio

class Timer:
    def __enter__(self):
        self.start_time = asyncio.get_running_loop().time()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        end_time = asyncio.get_running_loop().time()
        print(f"Execution time: {end_time - self.start_time}")

@Timer
async def compute_sum(n):
    total = 0
    for i in range(n):
        total += i
    return total

async def main():
    await compute_sum(1000000)

# Run the code and observe the output.
```

In this modified version, `Timer` is a context manager that measures the time between entering and exiting its block. The `compute_sum` function can be used as both an asynchronous and synchronous function, and the `Timer` will correctly measure its execution time in either case.
    
    ---
    *Generated on: 2026-02-21 16:02:34*
    