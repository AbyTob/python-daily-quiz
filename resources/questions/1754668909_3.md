# Python Quiz Question
    
    ## Question
    **Part 1 (Question):**

Consider the following Python code snippet that aims to create a decorator for async functions which measures their execution time:

```python
import asyncio
from functools import wraps

def measure_time(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start = asyncio.get_event_loop().time()
        result = await func(*args, **kwargs)
        end = asyncio.get_event_loop().time()
        print(f"{func.__name__} took {end - start:.4f} seconds to execute")
        return result
    return wrapper

@measure_time
async def async_task():
    await asyncio.sleep(2)
```

When running `asyncio.run(async_task())`, the expected output is:

A) "async_task took 0.0000 seconds to execute"  
B) "async_task took 2.0000 seconds to execute"  
C) The program raises an exception because decorators do not support async functions  
D) The execution time cannot be measured accurately for async functions
    
    ## Answer
    **Part 2 (Answer):**

B) "async_task took 2.0000 seconds to execute"

Explanation: The `measure_time` decorator is correctly implemented for async functions using the `@wraps(func)` decorator from the `functools` module, which preserves the metadata of the original function. When applied to an async function like `async_task`, it measures the execution time accurately by capturing the start and end times within the async context provided by `asyncio.get_event_loop().time()`. Therefore, when `asyncio.run(async_task())` is called, it should print "async_task took 2.0000 seconds to execute", as the function `async_task` suspends for 2 seconds using `await asyncio.sleep(2)`.
    
    ---
    *Generated on: 2025-08-08 16:01:49*
    