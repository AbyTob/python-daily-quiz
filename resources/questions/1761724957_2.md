# Python Quiz Question
    
    ## Question
    
    
    ## Answer
    **Part 1 (Question):**

Consider the following Python code that uses a combination of decorators, metaclasses, and async/await. The goal is to create a class that automatically measures the execution time of its methods when they are called.

```python
import asyncio

# Define a decorator to measure execution time
def time_logger(func):
    async def wrapper(*args, **kwargs):
        start_time = asyncio.get_event_loop().time()
        result = await func(*args, **kwargs)
        end_time = asyncio.get_event_loop().time()
        print(f"{func.__name__} took {end_time - start_time:.4f} seconds to run")
        return result
    return wrapper

# Define a metaclass that applies the time_logger decorator to all methods of a class
class TimeLoggerMeta(type):
    def __new__(cls, name, bases, dct):
        for attr_name, attr_value in dct.items():
            if callable(attr_value):
                dct[attr_name] = time_logger(attr_value)
        return super().__new__(cls, name, bases, dct)

# Apply the metaclass to a base class
class BaseClass(metaclass=TimeLoggerMeta):
    async def method1(self):
        await asyncio.sleep(0.2)

    async def method2(self):
        await asyncio.sleep(0.5)

# Create an instance of the subclass and call its methods
class SubClass(BaseClass):
    pass

async def main():
    sub = SubClass()
    await sub.method1()
    await sub.method2()

# Run the asyncio event loop to execute the methods
if __name__ == "__main__":
    asyncio.run(main())
```

Which of the following statements is true about this code?

A) The `time_logger` decorator does not work as expected because it's not properly applied to the methods when using a metaclass.

B) When you run the program, it will print the execution time for both `method1` and `method2`.

C) The `TimeLoggerMeta` metaclass is unnecessary since decorators can be directly applied to methods in Python.

D) Calling `main()` will raise an error because async methods cannot be decorated with regular decorators.

**Part 2 (Answer):**

B) When you run the program, it will print the execution time for both `method1` and `method2`.

Explanation: The provided code correctly uses a metaclass to apply a decorator to all callable attributes of its subclasses. In Python, when a class is instantiated with a metaclass that modifies its dictionary (`__new__` method), these modifications are applied to any instances created from the class. Therefore, calling `sub.method1()` and `sub.method2()` in the `main()` function will execute them with their execution times logged by the `time_logger` decorator, as intended.
    
    ---
    *Generated on: 2025-10-29 08:02:37*
    