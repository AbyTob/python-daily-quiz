# Python Quiz Question
    
    ## Question
    [QUESTION]
Imagine you're developing a framework for building web applications. You want to create a decorator that automatically logs the arguments with which a function is called, but only if the environment variable `DEBUG` is set to `True`. However, you also need this logging functionality to be optional and not affect the performance of the application when debugging is disabled.

Your task is to implement this feature using decorators. You should ensure that the decorator checks for the existence of the `DEBUG` environment variable before logging. If it's not present or is set to any value other than `True`, the function should execute without logging.

Here's a starting point:

```python
import os

def log_arguments(func):
    def wrapper(*args, **kwargs):
        # Check if DEBUG environment variable is True
        if os.getenv('DEBUG') == 'True':
            print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@log_arguments
def add(a, b):
    return a + b
```

Now, you're tasked with ensuring that this decorator is only applied to functions when `DEBUG` is set to `True`. You should not modify the `log_arguments` function itself but rather provide a way to conditionally apply it.

What is the correct approach to achieve this?

A) Remove the `@log_arguments` decorator from the `add` function and use a conditional statement inside the function to check for the `DEBUG` environment variable.

B) Define another decorator that checks for the `DEBUG` environment variable before applying the `log_arguments` decorator.

C) Modify the `log_arguments` decorator to include logic for checking the `DEBUG` environment variable internally.

D) Use a metaclass to conditionally apply the `log_arguments` decorator based on the presence of the `DEBUG` environment variable.
    
    ## Answer
    [ANSWER]
B) Define another decorator that checks for the `DEBUG` environment variable before applying the `log_arguments` decorator.

Explanation: The correct approach is to create a new decorator that checks if the `DEBUG` environment variable is set to `True`. If it is, this decorator should then apply the `log_arguments` decorator; otherwise, it should simply return the original function. This allows you to conditionally enable or disable logging without modifying the existing functions.

Here's an example of how you could implement this:

```python
import os

def log_arguments(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        return func(*args, **kwargs)
    return wrapper

def conditional_log(debug_decorator):
    def decorator(func):
        if os.getenv('DEBUG') == 'True':
            return debug_decorator(func)
        else:
            return func
    return decorator

@conditional_log(log_arguments)
def add(a, b):
    return a + b

# If DEBUG is set to True, this will print the arguments and result.
# If not, it will simply return the result without logging.
result = add(3, 5)
```

This approach allows you to maintain clean code while conditionally enabling or disabling logging based on the `DEBUG` environment variable.
    
    ---
    *Generated on: 2025-10-07 00:02:52*
    