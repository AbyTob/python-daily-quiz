# Python Quiz Question
    
    ## Question
    **Part 1 (Question):**

Consider the following code snippet:

```python
import asyncio

class AsyncDecorator:
    def __init__(self, func):
        self.func = func

    async def __call__(self, *args, **kwargs):
        print("Starting...")
        result = await self.func(*args, **kwargs)
        print("Finished!")
        return result

@AsyncDecorator
async def fetch_data():
    await asyncio.sleep(1)  # Simulate a delay
    return "Data fetched"

# Using the decorated function
loop = asyncio.get_event_loop()
result = loop.run_until_complete(fetch_data())
print(result)
```

Which of the following statements accurately describes what happens when this code is executed?

A) It will run synchronously, printing "Starting...", then "Finished!", and finally "Data fetched".

B) It will print "Starting..." and then wait for 1 second before printing "Finished!" and "Data fetched".

C) It will raise an error because decorators cannot be applied to asynchronous functions.

D) It will print "Starting...", then immediately return "Data fetched" without waiting for the sleep.

**Part 2 (Answer):**

B) It will print "Starting..." and then wait for 1 second before printing "Finished!" and "Data fetched".

Explanation:
- The `AsyncDecorator` is correctly applied to an asynchronous function `fetch_data`.
- When `fetch_data()` is called, it goes through the decorator first.
- Inside the decorator, it prints "Starting...", then awaits the result of `fetch_data()`. This means it waits for 1 second as simulated by `asyncio.sleep(1)`.
- After the sleep finishes, it prints "Finished!" and returns the result of `fetch_data()`, which is "Data fetched".
- The event loop correctly handles the asynchronous nature of the function, ensuring that the program pauses for 1 second when `await asyncio.sleep(1)` is encountered.
    
    ## Answer
    Answer format error. Please check the generated content.
    
    ---
    *Generated on: 2025-11-16 16:01:56*
    