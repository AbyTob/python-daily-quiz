# Python Quiz Question
    
    ## Question
    [QUESTION] Consider the following Python code snippet:

```python
from functools import wraps

def log_calls(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        return func(*args, **kwargs)
    return wrapper

class LoggedClass:
    __metaclass__ = type

    def __new__(cls, *args, **kwargs):
        obj = super(LoggedClass, cls).__new__(cls)
        return log_calls(obj)

    def method(self):
        print("Method called")

# Usage
logged_instance = LoggedClass()
logged_instance.method()
```

Which of the following statements is true regarding the behavior and implications of this code?

A) The `log_calls` decorator is applied to all methods of any class that inherits from `LoggedClass`.
B) The `__new__` method is correctly used to add logging functionality.
C) The `wrapper` function within `log_calls` has access to the original instance's attributes and methods directly.
D) Calling `logged_instance.method()` will not print any additional information.
    
    ## Answer
    [ANSWER] C) The `wrapper` function within `log_calls` has access to the original instance's attributes and methods directly.

Explanation: The `LoggedClass` uses a metaclass (`type`) that overrides the `__new__` method. Inside this overridden `__new__`, it returns an instance of a decorated version of itself using the `log_calls` decorator. However, since `log_calls` is applied to instances of classes derived from `LoggedClass`, and not directly to their methods, option A is incorrect. Option B is partially correct as the metaclass uses `__new__` correctly to add logging functionality but it does not apply to all methods of inheriting classes; it only logs calls to the instance itself (not its methods). Option C is correct because the `wrapper` function within `log_calls` operates on an instance that has already been created, thus having access to the original instance's attributes and methods. Option D is incorrect because calling `logged_instance.method()` will indeed print additional information due to the logging inside the `wrapper`.
    
    ---
    *Generated on: 2026-03-01 00:02:06*
    