# Python Quiz Question
    
    ## Question
    
    
    ## Answer
    **Question:**

You are tasked with creating a decorator that measures the execution time of any function it decorates. The decorator should also handle asynchronous functions (using `async/await`). Below is an initial attempt at writing such a decorator, but it does not work as expected for both synchronous and asynchronous functions.

```python
import asyncio
from functools import wraps
import time

def timing_decorator(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time() if not asyncio.iscoroutinefunction(func) else 0
        result = await func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time} seconds to execute")
        return result
    return wrapper

@timing_decorator
async def async_sleep():
    await asyncio.sleep(1)

def sync_function():
    time.sleep(1)
```

Identify what is wrong with the current implementation of `timing_decorator` and provide a corrected version that handles both synchronous and asynchronous functions correctly.

A) The decorator does not use `await` inside the wrapper for asynchronous functions, so it incorrectly reports zero execution time for async functions.  
B) The decorator fails to handle non-async functions properly, as it tries to call `asyncio.sleep()` even if the function is synchronous.  
C) Both A and B are correct.  
D) The implementation is correct and does not need any changes.

**Answer:**

C) Both A and B are correct.

The current implementation of `timing_decorator` has two main issues:
1. For asynchronous functions, it incorrectly reports zero execution time because the synchronous timing logic (`time.time()`) is used instead of waiting for the coroutine to complete with `await`.
2. For synchronous functions, it attempts to call `asyncio.sleep()` which raises an error since `sleep` is not a valid coroutine function.

Hereâ€™s how you can correct the decorator:

```python
import asyncio
from functools import wraps
import time

def timing_decorator(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time() if not asyncio.iscoroutinefunction(func) else 0
        result = await func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} took {end_time - start_time} seconds to execute")
        return result
    return wrapper

@timing_decorator
async def async_sleep():
    await asyncio.sleep(1)

def sync_function():
    time.sleep(1)

# Test with the corrected decorator
asyncio.run(async_sleep())  # Should print "async_sleep took X.XX seconds"
sync_function()  # Should print "sync_function took Y.YY seconds"
```

In this corrected version, `time.time()` is used for synchronous functions to get accurate execution time. For asynchronous functions, the decorator waits for the coroutine to complete with `await`, ensuring that the actual execution time of the coroutine is measured correctly.
    
    ---
    *Generated on: 2025-10-08 08:02:40*
    