# Python Quiz Question
    
    ## Question
    [QUESTION]  
Consider the following Python code using decorators:

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Something is happening before the function is called.")
        result = func(*args, **kwargs)
        print("Something is happening after the function is called.")
        return result
    return wrapper

@my_decorator
def say_hello(name):
    print(f"Hello {name}!")

say_hello("Alice")
```

This code defines a decorator `my_decorator` that logs messages before and after the execution of the decorated function. When calling `say_hello("Alice")`, it prints:

```
Something is happening before the function is called.
Hello Alice!
Something is happening after the function is called.
```

Now, let's consider a scenario where we want to modify this decorator so that it can accept arguments and use them in its wrapper. 

**Question:**
How can you modify `my_decorator` to accept parameters? Modify the code accordingly and provide an example of how to call the decorated function with these new capabilities.

A) 
```python
@my_decorator('extra')
def say_hello(name):
    print(f"Hello {name}!")
```

B)
```python
def my_decorator(message):
    def wrapper(func, *args, **kwargs):
        print("Something is happening before the function is called.")
        print(message)
        result = func(*args, **kwargs)
        print("Something is happening after the function is called.")
        return result
    return wrapper

@my_decorator('extra')
def say_hello(name):
    print(f"Hello {name}!")

say_hello("Alice")
```

C)
```python
def my_decorator(message):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print("Something is happening before the function is called.")
            print(message)
            result = func(*args, **kwargs)
            print("Something is happening after the function is called.")
            return result
        return wrapper
    return decorator

@my_decorator('extra')
def say_hello(name):
    print(f"Hello {name}!")

say_hello("Alice")
```

D)
```python
def my_decorator(message):
    def wrapper(func, *args, **kwargs):
        print("Something is happening before the function is called.")
        result = func(*args, **kwargs)
        print("Something is happening after the function is called.")
        return result
    return wrapper

@my_decorator('extra')
def say_hello(name):
    print(f"Hello {name}!")

say_hello("Alice")
```
    
    ## Answer
    C) 

**Explanation:**
The correct answer is C. This option correctly modifies `my_decorator` to accept a parameter and uses it within the wrapper function. Here's how it works:

```python
def my_decorator(message):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print("Something is happening before the function is called.")
            print(message)
            result = func(*args, **kwargs)
            print("Something is happening after the function is called.")
            return result
        return wrapper
    return decorator

@my_decorator('extra')
def say_hello(name):
    print(f"Hello {name}!")

say_hello("Alice")
```

When calling `say_hello("Alice")`, it now prints:

```
Something is happening before the function is called.
extra
Hello Alice!
Something is happening after the function is called.
```

This demonstrates how to create a decorator that can accept parameters and use them within its wrapper function.
    
    ---
    *Generated on: 2025-08-12 00:02:57*
    