# Python Quiz Question
    
    ## Question
    [QUESTION] Consider the following code snippet:

```python
from functools import wraps

def log_calls(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}")
        result = func(*args, **kwargs)
        print(f"{func.__name__} returned {result}")
        return result
    return wrapper

class LogCallsMeta(type):
    def __new__(cls, name, bases, dct):
        for attr_name, attr_value in dct.items():
            if callable(attr_value):
                dct[attr_name] = log_calls(attr_value)
        return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=LogCallsMeta):
    def method1(self, x):
        return x + 1

    def method2(self, a, b):
        return a * b
```

Which of the following statements is true about the given code?

A) The `log_calls` decorator will not be applied to methods in `MyClass`.

B) Calling an instance method from `MyClass` will print detailed logs before and after the method call.

C) Only `method1` will have its calls logged, while `method2` will not.

D) `LogCallsMeta` does not work as expected because it is incorrectly applied to class methods.
    
    ## Answer
    B) Calling an instance method from `MyClass` will print detailed logs before and after the method call.

**Explanation:** The metaclass `LogCallsMeta` dynamically wraps all callable attributes (methods) of the class `MyClass` with the `log_calls` decorator. This means that when you create an instance of `MyClass` and call any of its methods, the decorator will print logs before and after each method execution, as demonstrated in the code example.
    
    ---
    *Generated on: 2025-08-11 00:01:53*
    