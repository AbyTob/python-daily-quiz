# Python Quiz Question
    
    ## Question
    [QUESTION]
Consider the following Python code that uses a metaclass and a class decorator:

```python
class Meta(type):
    def __new__(cls, name, bases, dct):
        dct['method'] = lambda self: "Hello from Meta!"
        return super().__new__(cls, name, bases, dct)

def deco(cls):
    cls.class_method = lambda cls: "Hello from Deco!"
    return cls

@deco
class MyClass(metaclass=Meta):
    pass

obj = MyClass()
print(obj.method())  # Outputs "Hello from Meta!"
print(MyClass.class_method())  # Outputs "Hello from Deco!"
```

What happens if we change the order of `meta` and `deco` in the decorator application? Explain why this happens.

A) The program will raise an error because decorators are applied in reverse order.
B) The output of both method calls will remain unchanged.
C) The output of `obj.method()` will change to "Hello from Deco!", while the second call remains the same.
D) The output of `MyClass.class_method()` will change to "Hello from Meta!", while the first call remains the same.
    
    ## Answer
    [D]
The order in which decorators are applied matters. In Python, decorators are applied from the innermost (nearest to the function/method definition) to the outermost. So if we switch the order of `meta` and `deco`, the actual application will be:

```python
@deco
@Meta
class MyClass:
    pass
```

This means that when `MyClass` is created, it first goes through the `Meta` metaclass to add the `method` attribute. Then it goes through the `deco` decorator to add the `class_method` attribute. As a result, calling `obj.method()` will still output "Hello from Meta!", but calling `MyClass.class_method()` will now output "Hello from Deco!".
    
    ---
    *Generated on: 2025-09-06 08:01:51*
    