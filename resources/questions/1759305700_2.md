# Python Quiz Question
    
    ## Question
    [QUESTION]  
Consider the following Python code snippet that demonstrates a decorator for class methods:

```python
from functools import wraps

def log_method_calls(cls):
    for name, value in cls.__dict__.items():
        if callable(value) and not name.startswith('__'):
            setattr(cls, name, wrap_method(value))
    return cls

def wrap_method(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Calling method {func.__name__} with args {args[1:]} and kwargs {kwargs}")
        return func(*args, **kwargs)
    return wrapper

@log_method_calls
class Calculator:
    def add(self, a, b):
        return a + b
    
    def subtract(self, a, b):
        return a - b
```

Which of the following statements accurately describes what happens when an instance of `Calculator` is created and a method is called on it?

A) The decorator `log_method_calls` logs each method call without modifying the original methods.
B) The decorator `log_method_calls` dynamically replaces each callable method in `Calculator` with a new function that logs calls before executing the original method.
C) When an instance of `Calculator` is created, no changes are made to its methods; only the class itself gets a new attribute.
D) The methods `add` and `subtract` are not callable after applying the decorator.
    
    ## Answer
    B) The decorator `log_method_calls` dynamically replaces each callable method in `Calculator` with a new function that logs calls before executing the original method.
    
    ---
    *Generated on: 2025-10-01 08:01:41*
    