# Python Quiz Question
    
    ## Question
    **Part 1: Question**

Consider the following Python code snippet:

```python
import asyncio

class AsyncDecorator:
    def __init__(self, func):
        self.func = func
    
    def __call__(self, *args, **kwargs):
        return asyncio.run(self.func(*args, **kwargs))

@AsyncDecorator
async def fetch_data():
    await asyncio.sleep(1)
    return "Data fetched"

async def main():
    result = fetch_data()
    print(result)

if __name__ == "__main__":
    asyncio.run(main())
```

What is the primary purpose of using a metaclass or decorator in this context to enhance the functionality of `fetch_data`?

A) To add logging before and after the function execution  
B) To manage asynchronous operations without blocking the main thread  
C) To create a persistent connection for database queries  
D) To validate input parameters before executing the function

**Part 2: Answer**

B) To manage asynchronous operations without blocking the main thread

The `AsyncDecorator` class and its use of `asyncio.run()` inside the `__call__` method ensure that the `fetch_data` coroutine is run in an event loop, which does not block the main thread. This is crucial for maintaining responsiveness in applications that require handling multiple asynchronous tasks concurrently.
    
    ## Answer
    Answer format error. Please check the generated content.
    
    ---
    *Generated on: 2025-10-28 00:01:30*
    