# Python Quiz Question
    
    ## Question
    [QUESTION]
You are tasked with designing a system that manages user sessions in an asynchronous web application. The system should be able to track the expiration of sessions automatically when they expire, without requiring explicit calls to cleanup functions. You decide to use Python's `asyncio` and metaclasses to achieve this.

Consider the following code snippet:

```python
import asyncio

class SessionManager:
    def __init__(self):
        self.sessions = {}

    async def add_session(self, user_id, expiration_time):
        self.sessions[user_id] = expiration_time
        await asyncio.sleep(expiration_time)
        del self.sessions[user_id]

class MetaSession(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]
```

You want to ensure that each session is automatically removed from the `sessions` dictionary when it expires. However, you also want to make sure that only one instance of `SessionManager` exists throughout the application, regardless of how many times it is instantiated.

Which of the following approaches correctly implements both features?

A) Inherit `MetaSession` from `SessionManager` and use it as the metaclass for a new class that wraps `SessionManager`.

B) Modify the `add_session` method to check if the session has expired before adding it to the dictionary, and modify the metaclass to ensure only one instance of `SessionManager` exists.

C) Create a separate metaclass that combines both functionalities (singleton and automatic expiration).

D) Implement a decorator that automatically removes sessions when they expire, but do not use a metaclass to enforce the singleton pattern.
    
    ## Answer
    [ANSWER] C

The correct approach is to create a separate metaclass that combines both functionalities. This can be achieved by inheriting `MetaSession` from `type` and adding logic to handle session expiration within the `__call__` method. Additionally, you can use another metaclass or a different design pattern to ensure that only one instance of `SessionManager` exists throughout the application.

Here's an example implementation:

```python
import asyncio

class MetaSession(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class SessionManager(metaclass=MetaSession):
    def __init__(self):
        self.sessions = {}

    async def add_session(self, user_id, expiration_time):
        if user_id in self.sessions:
            await asyncio.sleep(expiration_time - (time.time() - self.sessions[user_id]))
        else:
            await asyncio.sleep(expiration_time)
        del self.sessions[user_id]
```

In this implementation, the `MetaSession` metaclass ensures that only one instance of `SessionManager` exists. The `add_session` method is modified to check if a session already exists for a user and adjust the sleep duration accordingly. This way, sessions are automatically removed when they expire without requiring explicit cleanup calls.
    
    ---
    *Generated on: 2026-02-10 00:03:10*
    