# Python Quiz Question
    
    ## Question
    Part 1 (Question): 

Imagine you have a Python script that needs to handle both synchronous and asynchronous operations efficiently. You decide to use `asyncio` for the asynchronous tasks but need a way to seamlessly integrate it with existing synchronous code without rewriting everything as an asynchronous function.

You create a decorator called `run_async_if_needed` that checks if the current execution context allows for asynchronous calls (i.e., if there's an event loop running). If it does, the decorator should run the wrapped function asynchronously using `asyncio.run()`. Otherwise, it should just call the function synchronously.

Here’s the initial implementation of `run_async_if_needed`:

```python
import asyncio

def run_async_if_needed(func):
    async def wrapper(*args, **kwargs):
        return await func(*args, **kwargs)
    
    def sync_wrapper(*args, **kwargs):
        return func(*args, **kwargs)

    if asyncio.get_event_loop().is_running():
        return wrapper
    else:
        return sync_wrapper

# Example usage
@run_async_if_needed
async def async_task():
    print("Running an asynchronous task")

def sync_task():
    print("Running a synchronous task")
```

Now, consider the following scenario:

1. You have an event loop running.
2. You call `sync_task()` within a context where there is no active event loop (e.g., in a new thread).
3. You attempt to call `async_task()` from that same thread.

Which of the following statements best describes what will happen when you run this code?

A) Both `sync_task()` and `async_task()` will execute synchronously.
B) `sync_task()` will execute synchronously, but `async_task()` will raise an error.
C) Both `sync_task()` and `async_task()` will attempt to create a new event loop and execute asynchronously.
D) `sync_task()` will execute synchronously, and `async_task()` will be executed asynchronously using the current event loop.
    
    ## Answer
    Part 2 (Answer):

A) Both `sync_task()` and `async_task()` will execute synchronously.

**Explanation:**
- When `sync_task()` is called with an active event loop, the decorator checks if there's an event loop running. Since there is one, it uses the synchronous wrapper (`sync_wrapper`), which simply calls the function without any change.
- For `async_task()`, even though there is an event loop, the decorator checks and determines that since it’s already running inside an async context (i.e., within a function marked with `@run_async_if_needed` or called from another async function), it should not attempt to run it again. Thus, it calls the synchronous wrapper (`sync_wrapper`) which simply returns the result of `async_task()`, effectively executing it synchronously without creating a new event loop.
    
    ---
    *Generated on: 2025-09-22 00:02:29*
    