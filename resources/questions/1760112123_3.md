# Python Quiz Question
    
    ## Question
    [QUESTION]
You are tasked with creating a Python application that needs to handle concurrent requests efficiently. You decide to use async/await for asynchronous operations, but you also need to ensure that each request is handled by a separate task. 

To achieve this, you create a custom decorator `@run_in_new_task` that runs the decorated function in a new asyncio Task. Here's how you might start implementing it:

```python
import asyncio

def run_in_new_task(func):
    async def wrapper(*args, **kwargs):
        loop = asyncio.get_event_loop()
        task = loop.create_task(func(*args, **kwargs))
        # Wait for the task to complete and get its result
        return await task
    return wrapper

@run_in_new_task
async def handle_request():
    print("Handling request")
    await asyncio.sleep(1)  # Simulate a network operation
    print("Request handled")

# Example usage:
async def main():
    await asyncio.gather(
        handle_request(),
        handle_request(),
        handle_request()
    )

# Run the application
asyncio.run(main())
```

What potential issue could arise from this implementation when dealing with a large number of concurrent requests?

A) The `run_in_new_task` decorator will create too many tasks, exhausting system resources.
B) The `await task` statement will not properly await the completion of the task, causing it to run in the foreground.
C) Since `asyncio.get_event_loop()` is called within the decorator, it may lead to issues if multiple event loops are created or accessed simultaneously.
D) None of the above.
    
    ## Answer
    [ANSWER] A

Explanation: The `run_in_new_task` decorator does not handle task management properly. When you call `asyncio.get_event_loop().create_task(func(*args, **kwargs))`, it creates a new task but does not wait for it to complete. This means that the function will immediately return without waiting for the task to finish, which can lead to resource exhaustion if many tasks are created concurrently. A better approach would be to use `asyncio.create_task` directly on the coroutine returned by the decorated function and then await it.
    
    ---
    *Generated on: 2025-10-10 16:02:03*
    